var fs = fs||require("fs");


var translationPair = {
	"はじめから" : "Start!"
}


var bufferSplit = function(splitBuf, buf, includeDelim) {
	var search = -1
	, lines = []
	, move = includeDelim?splitBuf.length:0
	;

	while((search = buf.indexOf(buf, splitBuf)) > -1){
		lines.push(buf.slice(0,search+move));
		buf = buf.slice(search+splitBuf.length,buf.length);
	}

	lines.push(buf);
		
	return lines;

}

var bufferExplode2 = function(splitBuf, buf, includeDelim) {
	splitBuf = Buffer.from(splitBuf);
	buf = Buffer.from(buf);
	var findAt = -1
	var lines = []
	var move = includeDelim?splitBuf.length:0

	var offset = 0;
	while ((findAt = buf.indexOf(splitBuf, offset)) > -1) {
	//while((search = buf.indexOf(buf, splitBuf)) > -1){
		//lines.push(buf.slice(0,search+move));
		//buf = buf.slice(search+splitBuf.length,buf.length);
	//}	
		//console.log('find at : ', findAt, buf.slice(offset, findAt));
		lines.push(buf.slice(offset, findAt));
		offset = findAt+splitBuf.length+1;
	}

	//lines.push(buf);
	//console.log(lines);
	return lines;

}

var bufferExplode = function(splitBuf, buf) {
	// Subject to change
	splitBuf = Buffer.from(splitBuf)
	var bufJ = buf.join(' ');
	var splitBufJ = splitBuf.join(' ');
	var splitS = bufJ.split(splitBufJ);
	var result = [];
	for (var i=0; i<splitS.length; i++) {
		var thisWord = splitS[i].trim();
		if (thisWord.length == 0) {
			result.push(Buffer.from([]))
			continue;
		}
		result.push(Buffer.from(thisWord.split(' ')));
	}
	return result;
}

var bufToHexArray = function(buf) {
	buf = Buffer.from(buf)
	var result = [];
	for (var i=0; i<buf.length; i++) {
		result.push(buf[i].toString(16).padStart(2, "0"))
	}
	return result.join(" ");
}

var iconv = iconv||require('iconv-lite');

var WolfData = function(file, writeMode, options) {
	options = options||{};
	this.options = options;
	
	this.file = file;
	this.fileName = file.split(/.*[\/|\\]/)[1];
	this.stringEncoding = options.stringEncoding || 'Windows-31j'	// translate from Japanese
	this.translationPair = options.translationPair || {};
	this.translationInfo = options.translationInfo || {};
	
	this.data = fs.readFileSync(file);
	this.flags = {};
	this.length = this.data.length;
	this.pointer = 0;
	
	this.currentContext = [];
	this.currentGroup = ""
	
	this.translatableString = [];
	this.storeBlank = false; // store blank string?
	
	this.writeMode = false;
	if (writeMode) {
		this.writeMode =true;
		this.writeBuffer = Buffer.from([]);
		this.regBuffer = []
	}
	
	this.isParseSuccess = false;
}

WolfData.prototype.write = function(path) {
	this.writeBuffer = Buffer.concat(this.regBuffer);
	fs.writeFileSync(path, this.writeBuffer);
}

WolfData.prototype.groupEnter = function(buff) {
	this.currentGroup = buff;
}
WolfData.prototype.groupExit = function(buff) {
	this.currentGroup = "";
}

WolfData.prototype.contextEnter = function(context) {
	this.currentContext.push(context);
	return this.currentContext;
}
WolfData.prototype.contextExit = function() {
	// exit one level of context
	return this.currentContext.pop();
}

WolfData.prototype.translate = function(text) {
	////console.log("attempt to translate ", text);
	if (typeof text !== 'string') return text;
	if (text == '') return text;

	// compare with exact context match
	var prefix = this.currentContext.join("/")
	prefix = prefix+"\n";
	if (Boolean(this.translationPair[prefix+text])) return this.translationPair[prefix+text];

	// compare with group
	var sliceLevel = this.translationInfo.groupLevel || 0;
	if (sliceLevel > 0) {
		prefix = this.currentContext.slice(0, sliceLevel).join("/")
		prefix = prefix+"\n";
		//if (window.monitoringMode) console.log("%cTranslate by group",  'background: #00F; color: #fff', prefix);
		if (Boolean(this.translationPair[prefix+text])) return this.translationPair[prefix+text];
	}
	
	if (typeof this.translationPair[text] == 'undefined') return text;
	
	return this.translationPair[text];
}

WolfData.prototype.createTextBuffer = function(text) {
	// Generating wolfRPG Style text buffer
	var textBuffer = iconv.encode(text, this.stringEncoding);
	var byteLength = Buffer.allocUnsafe(4)
	byteLength.writeInt32LE(textBuffer.length + 1); // plus end byte
	var result = []
	result.push(byteLength, textBuffer, Buffer.from([0x00]));
	return Buffer.concat(result);
}

WolfData.prototype.translatableTextAdd = function(textBuffer, context, translateLastBuffer) {
	// textBuffer is Buffer object
	context = context||[];
	
	
	if (this.storeBlank == false) {
		if (textBuffer.length < 1) return;
	}
	
	if (Array.isArray(context) == false) context = [context];
	translateLastBuffer = translateLastBuffer||false;

	var text = iconv.decode(textBuffer, this.stringEncoding)
	
	var tmpContext = this.currentContext.concat(context)
	
	this.translatableString.push({
		"text":text,
		"context":tmpContext,
		"buffer" : textBuffer,
		"group" : this.currentGroup
	})
	/*
	if (text == "o Manage Weapons") {
			console.log("%cMonitoring", 'background: #F00; color: #fff',translateLastBuffer, text, this.translationPair);
			window.monitoringMode = true;
	}
	*/
	// DO TRANSLATION HERE
	if (translateLastBuffer) {
		var translation = this.translate(text);
		if (Boolean(translation) == false) return;
		
		if (text !== translation) {
			console.log("%cTranslating", 'background: #222; color: #bada55', text,"->", translation, this.translationPair);
			
			var last = this.regBuffer.length -1;
			console.log("%cattempt to apply translated text into ", 'color: #ff0000', last, this.regBuffer[last]);
			this.regBuffer[last] = this.createTextBuffer(translation);		
		}

	}
	//window.monitoringMode = false;
}

WolfData.prototype.registerBuffer = function(buffer) {
	if (this.writeMode == false) return;
	// create a copy from buffer
	// and store it into regBuffer
	this.regBuffer.push(Buffer.from(buffer)); 
	return this.regBuffer;
}

WolfData.prototype.setFlags = function(key, value) {
	if (typeof key == 'undefined') return console.warn("Unable to set flags because of the blank key");
	this.flags[key] = value
	return this.flags;
}

WolfData.prototype.getFlags = function(key) {
	if (typeof key == 'undefined') return this.flags;
	return this.flags[key]
}

WolfData.prototype.set = function(key, value) {
	if (typeof key == 'undefined') return console.warn("Unable to set flags because of the blank key");
	this[key] = value
	return this[key];
}
WolfData.prototype.get = function(key)  {
	if (typeof key == 'undefined') return this;
	return this[key]
}

/*
WolfData.prototype.readPartial = function(length, pointer) {
	pointer = pointer||this.pointer;
	data = this.data.slice(pointer, pointer+length)
	this.pointer +=data.length;
	return data;
}
*/

WolfData.prototype.nextIndexOf = function(needle, pointer) {
	pointer = pointer||this.pointer;
	return thisData.indexOf(needle, pointer+1);
}
WolfData.prototype.distanceOf = function(needle, pointer) {
	// calculate distance from current pointer to the next occurance of needle
	// return current pointer if not exist
	pointer = pointer||this.pointer;
	var nextLocation =  this.data.indexOf(needle, pointer);
	if (nextLocation == -1) nextLocation = pointer;
	//console.log("Calculating distance : ", pointer, nextLocation);
	return nextLocation-pointer;
}

WolfData.prototype.resetPointer = function() {
	this.pointer = 0;
}



WolfData.prototype.goTo = function(num) {
	if (typeof num == 'undefined') return console.warn("Trying to set illegal value to pointer");
	this.pointer = num;
	return this.pointer;
}
WolfData.prototype.setPointer = function(pointer) {
	// alias of goTo
	return this.goTo(pointer);
}
WolfData.prototype.currentPos = function(pointer) {
	return this.pointer;
}

WolfData.prototype.read = function(numberOfByte, pointer) {
	// read portion of data by numberOfByte
	// update the pointer
	pointer = pointer||this.pointer;
	numberOfByte = numberOfByte||0;
	this.pointer = pointer+numberOfByte;
	var data = this.data.slice(pointer, pointer+numberOfByte);
	
	// register the buffer in writeMode
	this.registerBuffer(data);
	
	return data;
}

WolfData.prototype.readByte = function(pointer) {
	pointer = pointer||this.pointer;
	return this.read(1)[0];
}

WolfData.prototype.readInteger32LE = function(pointer) {
	pointer = pointer||this.pointer;
	var thisData = this.read(4);
	return thisData.readInt32LE();
}

WolfData.prototype.readStringBlind = function(context, pointer) {
	// read string blindly by delimiter
	context = context||[];
	if (Array.isArray(context) == false)context = [context]
	
	pointer = pointer||this.pointer;
	var stringTerminator = Buffer.from([0x00]);
	var resultBuffer = this.readToPoint(stringTerminator)
	var result = resultBuffer.toString();
	this.read(1); // read terminator but skipping it from result
	
	this.translatableTextAdd(resultBuffer, context);
	
	return result;
}

WolfData.prototype.readString = function(context, pointer, encoding) {
	// readString by header length
	/*
	string format
	0b 00 00 00 50 61 72 74 79 20 49 6e 66 6f 00  

	0b 00 00 00 => describes data length (strings and an end byte 0x00)
	50 61 72 74 79 20 49 6e 66 6f 00 => body string with 00 tail

	if the string is empty :
	01 00 00 00 00

	*/
	encoding = encoding||this.stringEncoding;
	pointer = pointer||this.pointer;
	context = context||[];
	if (Array.isArray(context) == false)context = [context]
	
	//var dataLength = this.readInteger32LE(pointer);
	var dataLength = this.getNext(4).readInt32LE();
	if (this.pointer+dataLength > this.length) {
		console.warn("Attempting to read ",dataLength, "at", this.pointer, "which is greater then document length");
		return this.readStringBlind(pointer);
	}
	var stringBuffer = this.getNext(dataLength-1, this.pointer+4);

	var string = "";
	if (encoding == 'utf8') {
		string = stringBuffer.toString(encoding)
	} else {
		string = iconv.decode( stringBuffer,encoding)
	}
	
	//this.pointer = this.pointer+dataLength;
	this.read(dataLength+4); // register to reader
	this.translatableTextAdd(stringBuffer, context, true);
	
	return string;
}

WolfData.prototype.readIntArray = function(pointer) {
	pointer = pointer||this.pointer;
	var thisLength = this.readByte();
	var result = [];
	for (var i=0; i< thisLength; i++) {
		result.push(this.readInteger32LE());
	}
	return result;
}
WolfData.prototype.readStringArray = function(context, pointer) {
	pointer = pointer||this.pointer;
	context = context||[];
	if (Array.isArray(context) == false)context = [context]
	
	var thisLength = this.readByte();
	//console.log("Expected array length is : ", thisLength);
	var result = [];
	for (var i=0; i< thisLength; i++) {
		context.push(i)
		result.push(this.readString(context));
	}
	return result;
}
WolfData.prototype.readRawArray = function(pointer) {
	pointer = pointer||this.pointer;
	var thisLength = this.readByte();
	var result = [];
	for (var i=0; i< thisLength; i++) {
		result.push(this.read(4));
	}
	return result;
}


WolfData.prototype.readToPoint = function(stringTerminator, pointer) {
	// place the pointer in front of the stringTerminator
	pointer = pointer||this.pointer;
	stringTerminator = stringTerminator||Buffer.from([0x00]);
	var result = this.read(this.distanceOf(stringTerminator));
	//this.read(stringTerminator.length); // read and shift to string terminator end pos
	//this.pointer = this.pointer+stringTerminator.length // shift to string terminator length
	return result;
}
/*
WolfData.prototype.verify = function(check, pointer) {
	pointer = pointer||this.pointer;
	check = Buffer.from(check);
	var parts = this.read(check.length)
	var result = check.equals(parts);
	if (result == false) {
		console.warn("Verify not match, trying to find ", check, "found", parts, "instead. Pointer is at :", this.pointer);
		console.trace();
	}
	return result;
}
*/
WolfData.prototype.verify = function(check) {
	var result;
	for (var i=0; i<arguments.length; i++) {
		var thisBuf = Buffer.from(arguments[i]);
		var parts = this.getNext(thisBuf.length);
		
		result = thisBuf.equals(parts);
		if (result == true) {
			this.read(thisBuf.length);
			return true;
		}
	}
	
	// only read the first arguments;
	check = Buffer.from(check);
	var parts = this.read(check.length)
	
	console.warn("Verify not match, trying to find ", check, "found", parts, "instead. Pointer is at :", this.pointer);
	console.trace();

	return false;
}

WolfData.prototype.nextIs = function(check) {
	// like verify but doesn't change the pointer
	check = Buffer.from(check);
	return check.equals(this.getNext(check.length));
}
/*
WolfData.prototype.seekTo = function(find, pointer) {
	// search buffer and place pointer after it
	// return new position pointer
	// register the range buffer
	pointer = pointer||this.pointer;
	find = Buffer.from(find);
	var result = this.data.indexOf(find, pointer);
	console.trace("seeking data found at: ", result);
	if (result == -1) {
		result = this.data.length;
	}
	result = result+find.length;
	this.pointer = result;
	console.warn("=========seekTo result : =========", this.pointer);
	return result;
}
*/
WolfData.prototype.seekTo = function(find, pointer) {
	// search buffer and place pointer after it
	// return new position pointer
	// register the range buffer
	pointer = pointer||this.pointer;
	find = Buffer.from(find);
	var result = this.data.indexOf(find, pointer);
	console.trace("seeking data found at: ", result);
	if (result == -1) {
		result = this.data.length; // whole file
	} else {
		result = result+find.length;
	}
	//this.pointer = result;
	////console.log("calculated result are : ", result, "current pointer: ", this.pointer);
	this.read(result - this.pointer);
	
	//console.warn("=========seekTo result : =========", this.pointer);
	return this.pointer;
}
WolfData.prototype.getNext = function(numberOfByte, pointer) {
	// return numberOfByte after pointer
	// pointer doesn't change after operation
	pointer = pointer||this.pointer;
	numberOfByte = numberOfByte||0;
	return this.data.slice(pointer, pointer+numberOfByte);
}

WolfData.prototype.isEOF = function(find, pointer) {
	if (pointer == -1) return true;
	if (pointer >= this.data.length) return true;
	
	return false;
}

WolfData.prototype.shiftPointer = function(num) {
	this.pointer = this.pointer + num;
	return this.pointer;
}

WolfData.prototype.getPointerHex = function() {
	return this.pointer.toString(16)	
}

WolfData.prototype.getChunk = function(from, to) {
	return this.data.slice(from, to);
}


// =============================================================
// C O M M A N D
// =============================================================

var WolfCommand = function(wolfData, position) {
	this.wolfData = wolfData
	this.position = position||this.wolfData.position
	this.positionHex = position.toString(16);
	//this.commandTerminator = Buffer.from([0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00]);
	this.commandTerminator = Buffer.from([0x03, 0x00, 0x00, 0x00]);
	this.commandTerminatorCE = Buffer.from([0x01, 0x00, 0x00, 0x00]);
	
	try {
		this.parse();	
	} catch(e) {
		console.error(e);
	}
}
// Command list with their parameter length.
// length are the paramter only. including end byte 0x00. Whole data length is this length + 5
WolfCommand.dataType = {
	0   : {"type":"Blank", "length": -1 },
	5   : {"type":"Debug Text", "length": -1 },
	99  : {"type":"Checkpoint", "length": -1 },
	101 : {"type":"Message", "length": -1 },
	102 : {"type":"Choices", "length": -1 },
	103 : {"type":"Comment", "length": -1 },
	105 : {"type":"ForceStopMessage", "length": -1 },
	106 : {"type":"DebugMessage", "length": -1 },
	107 : {"type":"ClearDebugText", "length": -1 },
	111 : {"type":"VariableCondition", "length": -1 },
	112 : {"type":"StringCondition", "length": -1 },
	121 : {"type":"SetVariable", "length": 19 },
	122 : {"type":"SetString", "length": -1 },
	123 : {"type":"InputKey", "length": -1 },
	124 : {"type":"SetVariableEx", "length": -1 },
	125 : {"type":"AutoInput", "length": -1 },
	126 : {"type":"BanInput", "length": -1 },
	130 : {"type":"Teleport", "length": 23 },
	140 : {"type":"Sound", "length": -1 },
	150 : {"type":"Picture", "length": -1 },
	151 : {"type":"ChangeColor", "length": 11 },
	160 : {"type":"SetTransition", "length": 11 },
	161 : {"type":"PrepareTransition", "length": 3 },
	162 : {"type":"ExecuteTransition", "length": 3 },
	170 : {"type":"StartLoop", "length": 3 },
	171 : {"type":"BreakLoop", "length": 3 },
	172 : {"type":"BreakEvent", "length": 3 },
	173 : {"type":"EraseEvent", "length": 11 },
	174 : {"type":"ReturnToTitle", "length": 3 },
	175 : {"type":"EndGame", "length": 3 },
	176 : {"type":"goToLoopStart", "length": 3 }, 
	177 : {"type":"StopNonPic", "length": 3 },
	178 : {"type":"ResumeNonPic", "length": 3 },
	179 : {"type":"LoopTimes", "length": 7 },
	180 : {"type":"Wait", "length": 7 },
	201 : {"type":"Move", "length": -1 }, // special case
	202 : {"type":"WaitForMove", "length": 3 },
	210 : {"type":"CommonEvent", "length": -1 },
	211 : {"type":"CommonEventReserve", "length": 11 },
	212 : {"type":"SetLabel", "length": -1 },
	213 : {"type":"JumpLabel", "length": -1 },
	220 : {"type":"SaveLoad", "length": 11 },
	221 : {"type":"LoadGame", "length": 19 },
	222 : {"type":"SaveGame", "length": 19 },
	230 : {"type":"MoveDuringEventOn", "length": 3 },
	231 : {"type":"MoveDuringEventOff", "length": 3 },
	240 : {"type":"Chip", "length": 11 },
	241 : {"type":"ChipSet", "length": 7 },
	242 : {"type":"ChipOverwrite", "length": 27 }, // new?
	250 : {"type":"Database", "length": -1 },
	251 : {"type":"ImportDatabase", "length": -1 },
	270 : {"type":"Party", "length": 11 },
	280 : {"type":"MapEffect", "length": -1 },
	281 : {"type":"ScrollScreen", "length": 15 },
	290 : {"type":"Effect", "length": 31 },
	300 : {"type":"CommonEventByName", "length": -1 },
	401 : {"type":"ChoiceCase", "length": -1 },
	402 : {"type":"SpecialChoiceCase", "length": -1 },
	420 : {"type":"ElseCase", "length": -1 },
	421 : {"type":"CancelCase", "length": 7 },
	498 : {"type":"LoopEnd", "length": 3 },
	499 : {"type":"BranchEnd", "length": 3 }
	
}

WolfCommand.prototype.fetchData = function() {
	
}

WolfCommand.prototype.isEnd = function() {
	// don't use this
	var next3Byte = this.wolfData.getNext(3);
	var endByte = Buffer.from([0x01, 0x00, 0x00]);
	if (this.wolfData.getNext(5).equals(Buffer.from([0x01, 0x00, 0x00, 0x00, 0x00]))) return false; // blank event
	if (next3Byte.equals(endByte)) return true;
	return false;
}
WolfCommand.prototype.isEndOfCommand = function() {
	// don't use this
	if (this.wolfData.isEOF()) return true;
	//console.log("=======is end of command ======", this.wolfData.getNext(7), "expected : ",this.commandTerminator );
	if (this.wolfData.getNext(7).equals(this.commandTerminator)) return true;
	
	return false;
}

WolfCommand.prototype.getCommandType = function(id) {
	if (typeof WolfCommand.dataType[id] == 'undefined') {
		console.warn("unknown command ", id, "at", this.wolfData.currentPos());
		return "unknown";
	}
	return WolfCommand.dataType[id].type
	
}


WolfCommand.prototype.parse = function() {
	this.wolfData.contextEnter("Command");
	
	//console.log("Parsing Command")
	this.length = this.wolfData.readInteger32LE();
	
	this.command = [];

	for (var x=0; x<this.length; x++) {
		this.wolfData.contextEnter(x);
		
		var thisData = {}
		thisData.position = this.wolfData.pointer;
		thisData.positionHex = this.wolfData.pointer.toString(16);
		
		//console.log("start reading command from : ", thisData.position);
		
		thisData.rawArgs = this.wolfData.readRawArray();
		//console.log("Current raw args : ", thisData.rawArgs);
		thisData.commandId = thisData.rawArgs[0].readInt32LE();
		thisData.commandType = this.getCommandType(thisData.commandId);
		//console.log("Command type : ", thisData.commandType);
		this.wolfData.contextEnter(thisData.commandType);
		
		switch (thisData.commandId) {
			case 201: // route
				thisData.unknownParam = this.wolfData.read(9);
				thisData.routes = new WolfMoveRoute(this.wolfData, this.wolfData.currentPos());
			break;
			
			default:
				if (this.wolfData.nextIs(Buffer.from([0x00, 0x00]))) {
					// end here
					this.wolfData.read(3);
					
				} else {
					// try to read string
					this.wolfData.read(1);
					//console.log("attempting to read string aray at : ", this.wolfData.currentPos());
					thisData.stringArgs = this.wolfData.readStringArray();
					//console.log("result is : ", thisData.stringArgs);
					//console.log("Current possition : ", this.wolfData.currentPos());
					this.wolfData.read(1);
				}
				
		}
		thisData.endPos = this.wolfData.currentPos();
		//console.log("Command end pos at ", thisData.endPos);
		thisData.rawData = this.wolfData.getChunk(thisData.position, thisData.endPos);
		this.command.push(thisData);
		this.wolfData.contextExit();
		
		/*
		if (this.isEnd()) {
			var thisData = {};
			thisData.position = this.wolfData.pointer;
			thisData.positionHex = this.wolfData.pointer.toString(16);
			thisData.commandType = "End";
			thisData.rawParam = this.wolfData.read(2);
			thisData.rawTail = this.wolfData.read(1); 
			thisData.endPos = this.wolfData.pointer;
			thisData.dataLength = thisData.endPos-thisData.position;
			thisData.isEnd = true;
			this.command.push(thisData);
		}
		i++;
		*/
		
		this.wolfData.contextExit();
	}
	
	// go to the end of command;
	//console.log("closing command : ", this.wolfData.currentPos(), );
	this.wolfData.verify(this.commandTerminator, this.commandTerminatorCE);
	this.wolfData.contextExit();
	
}

var WolfMoveRoute = function(wolfData, position) {
	this.wolfData = wolfData
	this.position = position
	this.positionHex = position.toString(16);
	this.delimiter = Buffer.from([0x01, 0x00])
	
	this.parse();	
}

WolfMoveRoute.dataType = {
  "0": {
    "name": "Down"
  },
  "1": {
    "name": "Left"
  },
  "2": {
    "name": "Right"
  },
  "3": {
    "name": "Up"
  },
  "4": {
    "name": "Down Left"
  },
  "5": {
    "name": "Down right"
  },
  "6": {
    "name": "Up left"
  },
  "7": {
    "name": "Up right"
  },
  "8": {
    "name": "Face Down"
  },
  "9": {
    "name": "Face Left"
  },
  "10": {
    "name": "Face Down Right"
  },
  "11": {
    "name": "Face Up Right"
  },
  "12": {
    "name": "Face Down Left"
  },
  "13": {
    "name": "Turn Right"
  },
  "14": {
    "name": "Face Up Left"
  },
  "15": {
    "name": "Face Right"
  },
  "16": {
    "name": "Move random"
  },
  "17": {
    "name": "Move Toward Hero"
  },
  "18": {
    "name": "Move Away From hero"
  },
  "19": {
    "name": "Step Forward"
  },
  "20": {
    "name": "Step Backward"
  },
  "21": {
    "name": "Jump"
  },
  "22": {
    "name": "Turn Left"
  },
  "23": {
    "name": "Turn Left/Right Random"
  },
  "24": {
    "name": "Face Random Direction"
  },
  "25": {
    "name": "Face Away From Hero"
  },
  "26": {
    "name": "Assign Variable"
  },
  "27": {
    "name": "Face Toward Hero"
  },
  "28": {
    "name": "Add Variable"
  },
  "29": {
    "name": "Set Move Frequency"
  },
  "30": {
    "name": "Set Animation Speed"
  },
  "31": {
    "name": "Half0Tile Movement"
  },
  "32": {
    "name": "Iddle Animation Off"
  },
  "33": {
    "name": "Move Animation On"
  },
  "34": {
    "name": "Move Animation Off"
  },
  "35": {
    "name": "Fixed Direction On"
  },
  "36": {
    "name": "Fixed Direction Off"
  },
  "37": {
    "name": "Slip-Through On"
  },
  "38": {
    "name": "Slip-Through Off"
  },
  "39": {
    "name": "Always On Top On"
  },
  "40": {
    "name": "Always On Top Off"
  },
  "41": {
	"name": "??"
  },
  "44": {
    "name": "Set Opacity to X"
  },
  "45": {
    "name": "Set Height to X"
  },
  "46": {
    "name": "Wait X Frame"
  },
  "47": {
    "name": "Iddle Animation On"
  },
  "48": {
    "name": "Full-Tile Movement"
  },
  "49": {
    "name": "Pattern 1"
  },
  "50": {
    "name": "Pattern 2"
  },
  "51": {
    "name": "Pattern 3"
  },
  "52": {
    "name": "Pattern 4"
  },
  "53": {
    "name": "Approach Event"
  },
  "54": {
    "name": "Approach Position"
  },
  "55": {
    "name": "Set Move Speed"
  },
  "56": {
    "name": "Pattern 5"
  },
  "57": {
    "name": "Set Graphic to X"
  },
  "58": {
    "name": "Play Sound"
  }
};

WolfMoveRoute.dbResult = {};

WolfMoveRoute.prototype.fetchData = function() {
	var result = {};
	result.movementId = this.wolfData.readByte();
	WolfMoveRoute.dataType[result.movementId] = WolfMoveRoute.dataType[result.movementId]||{'name': "unknown"}
	result.movementType = WolfMoveRoute.dataType[result.movementId].name
	result.paramLength = this.wolfData.readByte();
	result.param = [];
	for (var i=0; i<result.paramLength; i++) {
		result.param.push(this.wolfData.readInteger32LE());
	}
	this.wolfData.verify(this.delimiter);
	//console.log("result", result);
	return result;

}

/*
WolfMoveRoute.prototype.fetchData = function() {
	var movementId = this.wolfData.readByte();
	console.log("Movement ID : ",movementId, WolfMoveRoute.dataType[movementId[0]],  "at", this.wolfData.currentPos());
	var result;
	if (typeof WolfMoveRoute.dataType[movementId[0]] == 'undefined') {
		//console.log("default handler");
		result = this.wolfData.readToPoint(this.delimiter);
		this.wolfData.read(this.delimiter.length);
		return result;
		
	}
	
	result = this.wolfData.read(WolfMoveRoute.dataType[movementId[0]].length);
	// delimiter
	this.wolfData.read(this.delimiter.length);
	return result;
}
*/

WolfMoveRoute.prototype.parse = function() {
	this.length = this.wolfData.readInteger32LE();
	
	this.route = [];
	for (var i=0; i<this.length; i++) {
		var thisData = {}
		thisData.position = this.wolfData.pointer;
		thisData.positionHex = this.wolfData.pointer.toString(16);
		//thisData.data = this.wolfData.readToPoint(delimiter)
		//console.log("parse movement child : ", this.wolfData.currentPos());
		thisData.data = this.fetchData();
		// to do : properly parse route length by movement code
		thisData.endPos = this.wolfData.currentPos();
		this.route.push(thisData)
	}
	
	this.endPos = this.wolfData.currentPos();
	
}

var WolfEventPage = function(wolfData, position) {
	this.wolfData = wolfData
	this.position = position
	this.positionHex = position.toString(16);
	
	this.parse();
}

WolfEventPage.prototype.parse = function() {
	this.wolfData.read(1);
	this.unknownHeader = this.wolfData.read(4);
	//this.unknownData1 = this.wolfData.readInteger32LE();
	this.graphicName = this.wolfData.readString("graphicName");
	this.graphicDirection = this.wolfData.readByte();
	this.graphicFrame = this.wolfData.readByte();
	this.graphicOpacity = this.wolfData.readByte();
	this.graphicRenderMode = this.wolfData.readByte();
	
	// Condition
	// Read raw buffer for now
	this.condition = this.wolfData.read(1+4 + 4*4 + 4*4);
	this.movement = this.wolfData.read(4);
	this.flags = this.wolfData.readByte();
	this.routeFlags = this.wolfData.readByte();
	this.routesStartAt = this.wolfData.pointer
	this.routes = new WolfMoveRoute(this.wolfData, this.wolfData.pointer);
	this.routesEndAt = this.wolfData.pointer
	this.commands = new WolfCommand(this.wolfData, this.wolfData.pointer);

	//console.log("At this page, command ended at : ", this.wolfData.currentPos());
	
	this.shadowGraphicNum = this.wolfData.readByte();
	this.collisionWidth = this.wolfData.readByte();
	this.collisionHeight = this.wolfData.readByte();
	this.terminator = this.wolfData.verify(Buffer.from([0x7a])); // should be 0x7a
	this.endPos = this.wolfData.pointer;
	this.endPosHex = this.endPos.toString(16);
	this.dataLength = this.endPos-this.position;
	

	
	//console.log("parsing page ended at : ", this.wolfData.currentPos());
	
	
}


var WolfEvent = function() {

}

var WolfEvents = function(wolfData) {
	this.wolfData = wolfData;
	this.terminator = Buffer.from([0x70])
	
	this.parse();
}

WolfEvents.prototype.parse = function() {
	var delimiter = Buffer.from([0x6f, 0x39, 0x30, 0x00, 0x00]);
	//console.log("calling wolfData from WolfEvents", this.wolfData);
	var parts = bufferExplode(delimiter, this.wolfData.data);
	//console.log("Event parts : ", parts);
	var partHeader = parts.shift();
	
	var eventLength = this.wolfData.getFlags("eventCount");
	if (typeof eventLength == 'undefined') {
		eventLength = parts.length;
	}
	
	this.wolfData.contextEnter("Event");
	
	this.events = []
	for (var i=0; i<parts.length; i++) {
		this.wolfData.contextEnter(i);
		
		var thisData = {};
		thisData.position = this.wolfData.currentPos();
		if (i==0) { // assign starting point of the very first event
			thisData.position = this.wolfData.seekTo(delimiter);
		} else {
			this.wolfData.verify(delimiter);
		}
		//console.log("\r\n========================");
		//console.log("Start parsing event at : ", thisData.position);
		thisData.data = parts[i];
		thisData.id = this.wolfData.readInteger32LE();
		thisData.name = this.wolfData.readString("name");
		thisData.x = this.wolfData.readInteger32LE();
		thisData.y = this.wolfData.readInteger32LE();
		thisData.numberOfPage = this.wolfData.readInteger32LE();
		thisData.unknownInt2 = this.wolfData.readInteger32LE();
		//console.log("Handling EVENT ", thisData.id, thisData.name, thisData);
		
		if (this.wolfData.getNext(1, Buffer.from([0x79]))) {
			//console.log("Event page found at", this.wolfData.pointer+1);
		}
		
		thisData.page = thisData.page||[];
		this.wolfData.contextEnter("page");
		for (var x=0; x<thisData.numberOfPage; x++) {
			this.wolfData.contextEnter(x);
			thisData.page.push(new WolfEventPage(this.wolfData, this.wolfData.pointer));
			this.wolfData.contextExit();
		}
		this.wolfData.contextExit();
		
		this.wolfData.verify(this.terminator); // end of event
		//console.log("end of event at ", this.wolfData.currentPos());


		this.events.push(thisData);
		this.wolfData.contextExit();
	}
	this.wolfData.contextExit();

	
}



var WolfMap = function(file, writeMode, options) {
	console.log("Parsing map file : ", file, arguments);
	options = options||{};
	this.wolfData = new WolfData(file, writeMode, options);
	this.data = this.wolfData.data;
	this.terminator = Buffer.from([0x66]);
	
	this.wolfData.contextEnter(this.wolfData.fileName);
	this.init();
	this.wolfData.contextExit();
	
}

WolfMap.marker = {
		'jp': {
			'header' : [
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x4F, 0x4C, 0x46, 0x4D, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x65, 0x05, 0x00, 0x00, 0x00, 0x82, 0xC8, 0x82, 
	  0xB5, 0x00
			]
		},
		'en': {
			'header' : [
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x57, 0x4F, 0x4C, 0x46, 0x4D, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00, 0x00, 0x65, 0x03, 0x00, 0x00, 0x00, 0x4e, 0x6f, 0x00
			]
		}
	}

WolfMap.prototype.init = function() {
	//console.log(WolfMap.marker);
	this.version = 'jp'
	if (this.data.includes(Buffer.from(WolfMap.marker.en.header))) this.version = 'en'
	if (this.version == 'jp' ) {
		console.info("Setting encoding to Windows-31j")
		this.wolfData.set('stringEncoding', 'Windows-31j');
	}
	
	this.marker = JSON.parse(JSON.stringify(WolfMap.marker[this.version]));
	this.wolfData.verify(this.marker.header);	
	this.parse();


	return this;
}

WolfMap.prototype.parse = function() {
	// WARNING :  ORDER DOES MATTER!
	//console.log("Parsing Map : ", this.wolfData.currentPos());
	this.tilesetId = this.wolfData.readInteger32LE();
	this.width = this.wolfData.readInteger32LE();
	this.height = this.wolfData.readInteger32LE();
	this.eventCount = this.wolfData.readInteger32LE();
	this.wolfData.setFlags("eventCount", this.eventCount);
	this.wolfEvents = new WolfEvents(this.wolfData);
	if (this.wolfData.verify(this.terminator)) this.success = true; // end of file
	this.wolfData.isParseSuccess = true;

}

// =============================================================
// C O M M O N  E V E N T
// =============================================================
var WolfCEFile = function(file, writeMode, options) {
	if (!(this instanceof WolfCEFile)) return console.warn("WolfCEFile is a constructor!")
	this.headerBuffer = Buffer.from([0x00, 0x57, 0x00, 0x00, 0x4F, 0x4C, 0x00, 0x46, 0x43, 0x00, 0x8F]);
	this.terminator = Buffer.from([0x8F]);
	this.wolfData = new WolfData(file, writeMode, options);
	
	this.wolfData.contextEnter(this.wolfData.fileName);
	this.parse();
	this.wolfData.contextExit();
}

WolfCEFile.prototype.parse = function() {
	this.wolfData.contextEnter("CommonEvent");
	
	this.wolfData.verify(this.headerBuffer)
	this.length = this.wolfData.readInteger32LE()
	
	this.commonEvents = [];
	for (var i=0; i<this.length; i++) {
		this.wolfData.contextEnter(i);
		this.commonEvents.push(new WolfCE(this.wolfData));
		this.wolfData.contextExit();
	}
	this.wolfData.verify(this.terminator);
	this.endPos = this.wolfData.currentPos();
	this.wolfData.contextExit();
	
	this.wolfData.isParseSuccess = true;
	
}

var WolfCE = function(wolfData) {
	if (!(this instanceof WolfCE)) return console.warn("WolfCE is a constructor!")
	this.headerBuffer = Buffer.from([0x8e])
	this.wolfData = wolfData;
	this.checkPointBuffer = Buffer.from([0x0a, 0x00, 0x00, 0x00]);
	this.parse();
}
WolfCE.prototype.parse = function() {
	//console.log("Common event start at : ", this.wolfData.currentPos());
	this.position = this.wolfData.currentPos();
	this.wolfData.verify(this.headerBuffer);
	this.id = this.wolfData.readInteger32LE();
	this.unknown1 = this.wolfData.readInteger32LE();
	this.unknown2 = this.wolfData.read(7);
	this.name = this.wolfData.readString("name");
	
	this.wolfData.groupEnter(this.name); // register group
	this.commands = new WolfCommand(this.wolfData, this.wolfData.currentPos())
	this.wolfData.groupExit(); // register group
	
	//console.log("command end at :", this.wolfData.currentPos());
    this.wolfData.verify(Buffer.from([0x00]));
    this.description = this.wolfData.readString("note")
	this.wolfData.verify(Buffer.from([0x8f]));
	
	
	// string arguments
	var stringArgsLength = this.wolfData.readInteger32LE();
	this.stringArgs = [];
	for (var i=0; i<stringArgsLength; i++) {
		this.stringArgs.push(this.wolfData.readString(["stringArgs", i]));
	}
	//console.warn("==============> int Args", this.wolfData.currentPos());
	
	var intArgsLength = this.wolfData.readInteger32LE();
	this.byteArgs = [];
	for (var i=0; i<intArgsLength; i++) {
		this.byteArgs.push(this.wolfData.readByte());
	}
	//console.warn("==============> Special arguments", this.wolfData.currentPos());
	
	// Special arguments
	var spArgsLength = this.wolfData.readInteger32LE();
	this.spOptionsArgs = [];
	for (var i=0; i<spArgsLength; i++) {
		var optionsLength = this.wolfData.readInteger32LE();
		var thisData = [];
		for (var x=0; x<optionsLength; x++) {
			thisData.push(this.wolfData.readString(["optionArgs", i, x]));
		}
		this.spOptionsArgs.push(thisData);
	}
	
	var spArgsLength = this.wolfData.readInteger32LE();
	this.spOptionsValArgs = [];
	for (var i=0; i<spArgsLength; i++) {
		var optionsLength = this.wolfData.readInteger32LE();
		var thisData = [];
		for (var x=0; x<optionsLength; x++) {
			thisData.push(this.wolfData.readInteger32LE());
		}
		this.spOptionsValArgs.push(thisData);
	}

	var defIntLength = this.wolfData.readInteger32LE();
	this.intArgs = [];
	for (var i=0; i<defIntLength; i++) { // only 5?
		this.intArgs.push(this.wolfData.readInteger32LE());
	}
	this.unknown3 = this.wolfData.read(5);
	
	//console.warn("==============> cSelf", this.wolfData.currentPos());
	this.cSelf = [];
	for (var i=0; i<100; i++) {
		this.cSelf.push(this.wolfData.readString(["cSelf", i]));
	}
	
	//console.warn("==============>", this.wolfData.currentPos());
	this.wolfData.verify(Buffer.from([0x91]));
	this.unknown4 = this.wolfData.readString('SKIPTHIS');
	this.wolfData.verify(Buffer.from([0x92]));
	this.unknown5 = this.wolfData.readString('SKIPTHIS');
	this.wolfData.read(4); // 0xff, 0xff, 0xff, 0xff
	this.wolfData.verify(Buffer.from([0x92]));
	
	this.endPos = this.wolfData.currentPos();
}

// =============================================================
// D A T A B A S E
// =============================================================

var WolfDatFile = function(file, writeMode, options) {
	if (!(this instanceof WolfDatFile)) return console.warn("WolfDatFile is a constructor!")
	console.log("Parsing .dat file : ", file, arguments);
	this.headerBuffer = Buffer.from([0x00, 0x57, 0x00, 0x00, 0x4F, 0x4C, 0x00, 0x46, 0x4D, 0x00, 0xC1]);
	this.terminator = Buffer.from([0xC1]);
	this.file = file;
	this.writeMode = writeMode;
	this.options = options || {}
	this.wolfData = new WolfData(file, writeMode, options);
	
	this.parse();
	
}

WolfDatFile.prototype.parse = function() {
	this.wolfData.contextEnter(this.wolfData.fileName);
	this.position = this.wolfData.currentPos();
	if (this.wolfData.verify(this.headerBuffer) == false) {
		console.warn("Skipping ", this.file, "reason: wrong header");
		return;
	}
	
	this.typesCount = this.wolfData.readInteger32LE();
	
	this.wolfData.contextEnter("db");
	this.types = []
	for (var i=0; i<this.typesCount; i++) {
		this.wolfData.contextEnter(i);
		this.types.push(new WolfDBType(this.wolfData));
		this.wolfData.contextExit();
	}
	this.wolfData.contextExit("db");
	
	this.wolfData.verify(this.terminator);
	this.endPos = this.wolfData.currentPos();
	this.wolfData.contextExit();
	
	this.wolfData.isParseSuccess = true;
	
}

var WolfDBType = function(wolfData) {
	if (!(this instanceof WolfDBType)) return console.warn("WolfDBType is a constructor!")
	this.headerBuffer = Buffer.from([0xFE, 0xFF, 0xFF, 0xFF]);
	this.terminator = Buffer.from([0xC1]);
	this.wolfData = wolfData;
	
	this.parse();
}
WolfDBType.prototype.parse = function() {
	this.position = this.wolfData.currentPos();
	this.wolfData.verify(this.headerBuffer);
	this.typeId = this.wolfData.readInteger32LE();
	this.fieldCount = this.wolfData.readInteger32LE();
	
	this.fieldTypes = [];
	for (var i=0; i<this.fieldCount; i++) {
		this.fieldTypes.push(this.wolfData.readInteger32LE());
		//this.fields.push(new WolfDBField(this.wolfData));
	}
	
	// sorting the types.
	// this will ensure that the string data will always parsed after int
	this.fieldTypes.sort(); 
	
	this.data = []
	this.dataLength = this.wolfData.readInteger32LE();
	for (var dataIndex=0; dataIndex<this.dataLength; dataIndex++) {
		var fieldData = [];
		for (var i=0; i<this.fieldCount; i++) {

			var thisData = {};
			thisData.position = this.wolfData.currentPos();
			if (this.fieldTypes[i] < 2000) {
				thisData.type = "int";
				thisData.value = this.wolfData.readInteger32LE();
			} else {
				thisData.type = "str";
				thisData.value = this.wolfData.readString(["fldSet", dataIndex, "idx", i, "val"]);
			}
			thisData.endPos = this.wolfData.currentPos();
			
			fieldData.push(thisData);
		}
		this.data.push(fieldData);
	}
	
	this.endPos = this.wolfData.currentPos();
}


// =============================================================
// G a m e . d a t
// =============================================================
var WolfGameDatFile = function(file, writeMode, options) {
	if (!(this instanceof WolfGameDatFile)) return console.warn("WolfGameDatFile is a constructor!")
	this.headerBuffer = Buffer.from([0x00, 0x57, 0x00, 0x00, 0x4F, 0x4C, 0x00, 0x46, 0x4D, 0x00]);
	this.terminator = Buffer.from([]);
	this.wolfData = new WolfData(file, writeMode, options);
	
	this.wolfData.contextEnter(this.wolfData.fileName);
	this.parse();
	this.wolfData.contextExit();
	this.wolfData.isParseSuccess = true;
}

WolfGameDatFile.prototype.parse = function() {
	this.position = this.wolfData.currentPos();
	this.wolfData.verify(this.headerBuffer);
	
	this.byteDataLength = this.wolfData.readInteger32LE();
	this.byteData = [];
	for (var i=0; i<this.byteDataLength; i++) {
		this.byteData.push(this.wolfData.readByte());
	}
	this.stringDataLength = this.wolfData.readInteger32LE();
	this.stringData = [];
	var stringContext = [
		"title",
		["unknown", "CAUTION"],
		["decryptKey", "CAUTION"],
		["font", 0, "CAUTION"],
		["font", 1, "CAUTION"],
		["font", 2, "CAUTION"],
		["font", 3, "CAUTION"],
		["font", 4, "CAUTION"],
		"version"
	]
	for (var i=0; i<this.stringDataLength; i++) {
		this.stringData.push(this.wolfData.readString(stringContext[i]));
	}

	// read the rest of data as a raw;
	this.dataBody = this.wolfData.read(this.wolfData.length - this.wolfData.currentPos());

	this.endPos = this.wolfData.currentPos();
}


// =============================================================
// WolfJs
// =============================================================
var WolfJs = function(path, writeMode, options) {
	// path is game.exe or game folder
	if (!(this instanceof WolfJs)) return console.warn("WolfJs is a constructor!")
	this.path = path;
	this.writeMode = writeMode;
	this.options = options||{};
	this.options.translationPair = this.options.translationPair||{};
	this.options.trnsData = this.options.trnsData||undefined;
	this.options.lineBreak = this.options.lineBreak||"\n";
	this.options.contextDelimiter = this.options.contextDelimiter || "/"
	this.options.stringEncoding = this.options.stringEncoding || "Windows-31j"; // assume source from japanese game
	/*
		groupType : 0
		no grouping
		
		groupType : 1
		grouping with ID
		
		groupType : 2
		grouping with name
		
	*/	
	this.options.groupType = this.options.groupType || 0 
	
	this.init();
}

WolfJs.prototype.getAllFiles = function(dir){
    fs = fs||require("fs");
    var results = [];
	var that = this;
    fs.readdirSync(dir).forEach(function(file) {

        file = dir+'/'+file;
        var stat = fs.statSync(file);

        if (stat && stat.isDirectory()) {
            results = results.concat(that.getAllFiles(file))
        } else results.push(file);

    });

    return results;	
	
}

WolfJs.prototype.isDir = function(dirPath) {
	var fs = fs || require('fs');
	return  fs.existsSync(dirPath) && fs.lstatSync(dirPath).isDirectory();
}

WolfJs.prototype.isFile = function(path) {
	var fs = fs || require('fs');
	return  fs.existsSync(path) && fs.lstatSync(path).isFile();
}

WolfJs.prototype.getDirName = function(path) {
	return path.match(/(.*)[\/\\]/)[1]||'';
}

WolfJs.prototype.getFileExtension = function(filename) {
  var ext = /^.+\.([^.]+)$/.exec(filename);
  return ext == null ? "" : ext[1].toLowerCase();
}
WolfJs.prototype.getRelPath = function(path) {
  return path.substr(this.path.length+1);
}


WolfJs.prototype.generateTransData = function(wolfData, forceUngroup) {
	// wolfData;
	forceUngroup = forceUngroup || false
	var groupLevel = 0; // group by the number of this length in the context
	if (this.options.groupType == 1) groupLevel = 3;
	if (forceUngroup) groupLevel = 0;
	
	var result = {}

	if (wolfData instanceof WolfData == false) {
		console.warn("invalid arguments, expected WolfData object", wolfData);
		return result;
	}
	

	
	for (var i=0; i<wolfData.translatableString.length; i++){
		var thisTextObj = wolfData.translatableString[i]
		var currentGroup = thisTextObj.context.slice(0, groupLevel);
		var groupId = this.options.contextDelimiter;
		if (currentGroup.length > 0) groupId = currentGroup.join(this.options.contextDelimiter)

		result[groupId] = result[groupId] || {
			data:[],
			context:[],
			indexIds:{},
			groupLevel:groupLevel,
			currentGroup : currentGroup
		}
		var index = result[groupId].data.length
		if (index == 0) {
			result[groupId].relPathArr = []
			result[groupId].filename = currentGroup[0]
			
			if (groupLevel > 0 ) {
				result[groupId].relPathArr = [currentGroup[1], currentGroup[2]]
				result[groupId].filename = [currentGroup[1], currentGroup[2]].join("/")			
			}
			
		}
		
		var text = iconv.decode(thisTextObj.buffer, this.options.stringEncoding);
		if (typeof result[groupId].indexIds[text] !== 'undefined') {
			result[groupId].context[result[groupId].indexIds[text]].push(thisTextObj.context.join(this.options.contextDelimiter));
			continue;
		}
			
		var row = [text, ""];
		thisTextObj.context = thisTextObj.context||[];

		result[groupId].data[index] = row;
		result[groupId].context[index] = [thisTextObj.context.join(this.options.contextDelimiter)];
		result[groupId].indexIds[text] = index;
		
	}
	
	return result;
}

WolfJs.prototype.analyseWolfExe = function(exePath) {
	var stats = fs.statSync(exePath)

	var reader = fs.createReadStream(exePath, { start: 3942936, end: 3942936+12 });
	reader.on('data', function(chunk) {
		console.log(chunk.toString());
	})	
}


WolfJs.prototype.getGameTitle = function(generatedData) {
	generatedData = JSON.parse(JSON.stringify(generatedData));
	generatedData = generatedData||{};
	generatedData.context = generatedData.context||[[]]
	
	for (var partId in generatedData) {
		var thisGenData = generatedData[partId]
	
	
		for (var row = 0; row<thisGenData.context.length; row++){
			if (Array.isArray(thisGenData.context[row]) == false) continue
			for (var idx = 0; idx<thisGenData.context[row].length; idx++) {
				var context = thisGenData.context[row][idx];
				console.log("checking context", context);
				if (context.includes("title")) {
					console.log("found keyword title", thisGenData.data[row]);
					return thisGenData.data[row][0];
				}
			}
		}
	}
	return "";
}

WolfJs.prototype.dump = function(format) {
	format = format || "trans"
	
	var RESULT = {};
	RESULT.project = {};
	RESULT.project.files = {};
	RESULT.project.gameEngine = "wolf";
	RESULT.project.parsedBy = "wolfJs";
	
	// dump to trans
	var files = {};
	for (var relativePath in this.files) {
		var thisFile = this.files[relativePath]
		var thisData = {};

		
		if (typeof thisFile.wolfFile == 'undefined') {
			console.warn("wolfFile is undefined", thisFile);
			continue;
		}
		
		if (thisFile.originalFormat == 'WRPGE Map File') {
			// GET directory from string, with no trailing slash
			thisData.dirname = relativePath.substring(0,relativePath.lastIndexOf("/"));
			var generatedData = this.generateTransData(thisFile.wolfFile.wolfData, true)
		} else if (thisFile.originalFormat == 'WRPGE Game.dat File') {
			thisData.dirname = relativePath.substring(0,relativePath.lastIndexOf("/"));
			var generatedData = this.generateTransData(thisFile.wolfFile.wolfData, true)
			RESULT.project.gameTitle = this.getGameTitle(generatedData);

		} else {
			// dirname is relativePath, because we will create group from the file
			thisData.dirname = relativePath; 
			var generatedData = this.generateTransData(thisFile.wolfFile.wolfData)
		}
		
		thisData.generatedData = generatedData;
		
		//Object.assign(thisData, this.generateTransData(thisFile.wolfFile.wolfData))
		
		for (var partId in generatedData) {
			var thisGenData = generatedData[partId]
			//console.log("handling ", partId, "data is ", thisGenData);
			thisGenData.relPathArr = thisGenData.relPathArr ||[];
			var thisPath = [relativePath].concat(thisGenData.relPathArr).join("/")
			//files[thisPath] = thisData;
			
			var thisFileName = relativePath.split(/.*[\/|\\]/)[1];
			//thisGenData.filename = thisGenData.filename || thisFileName
			
			files[thisPath] = {};
			files[thisPath].data 		= thisGenData.data
			files[thisPath].context 	= thisGenData.context
			files[thisPath].filename 	= thisGenData.filename || thisFileName
			files[thisPath].basename 	= thisGenData.filename || thisFileName
			files[thisPath].indexIds 	= thisGenData.indexIds
			files[thisPath].groupLevel 	= thisGenData.groupLevel;	
			files[thisPath].extension 	= thisFile.extension;
			files[thisPath].lineBreak 	= this.options.lineBreak;
			files[thisPath].path 		= relativePath; // path is relative path from cache dir
			files[thisPath].relPath 	= Boolean(thisGenData.filename) ? thisFileName+"/"+thisGenData.filename : ""; // relpath is real filename address on context	
			files[thisPath].type 		= null; // no special type
			files[thisPath].originalFormat = thisFile.originalFormat;			
			files[thisPath].dirname 	= thisData.dirname;	
			
		}
		
	}
	RESULT.project.files = files;
	
	return RESULT;
}

WolfJs.prototype.writeToFolder = function(targetFolder) {
	if (this.writeMode == false) return console.warn("Unablt to write. Reason : not in write mode!");
	
	for (var path in this.files) {
		var thisFiles = this.files[path]
		
		if (thisFiles.wolfFile.wolfData.isParseSuccess == false) {
			console.warn("skip processing ", path, "reason : Previously the file was not successfully parsed!");
			continue;
		}
		
		var targetPath = targetFolder+"/"+path;
		console.log("creating directory : ", this.getDirName(targetPath));
		try {
			fs.mkdirSync(this.getDirName(targetPath), {recursive:true});
		} catch(e) {
			console.warn("Unable to create directory ", this.getDirName(targetPath));
			throw(e);
			return;
		}
		
		console.log("Writing ", targetPath);
		thisFiles.wolfFile.wolfData.write(targetPath);
		console.log("    done");
	}
	
}

WolfJs.prototype.getTranslatonPairByPath= function(path) {
	/*
		result : {
			translationInfo : {
				
			},
			translationPair : {
				
			}
		}
	*/
	
	var transData = this.options.translationData || {};
	transData.translationData = transData.translationData|| {};
	transData.translationData[path] =transData.translationData[path]||{}
	transData.translationData[path].translationInfo = transData.translationData[path].translationInfo || {};
	transData.translationData[path].translationPair = transData.translationData[path].translationPair || {};
	console.log("Translation data for ", path, "is", transData.translationData[path]);
	return {
		translationInfo : transData.translationData[path].info,
		translationPair : transData.translationData[path].translationPair
	}
}

WolfJs.prototype.init = function() {
	// convert to forward slash
	this.path = this.path.replace(/\\/g,"/")
	this.contents = this.getAllFiles(this.path);
	
	this.files = {};
	for (var i=0; i<this.contents.length; i++) {
		var thisFile = this.contents[i]
		var thisData = {};
		//var thisOptions = JSON.parse(JSON.stringify(this.options));
		
		thisData.path = this.getRelPath(thisFile)	
		
		thisData.extension = this.getFileExtension(thisFile);
		thisData.basename = thisFile.split(/.*[\/|\\]/)[1];
		
		if (thisFile.length < 1) continue;
		if (["dat", "mps"].includes(thisData.extension) == false) continue;
		if (thisFile.indexOf("AutoBackup") !== -1 ) continue
		if (thisFile.indexOf("EditorGraphic.dat") !== -1 ) continue
		
		var translationInfo = this.getTranslatonPairByPath(thisData.path);
		console.warn("Translation Info", translationInfo);
		var thisOptions = Object.assign({}, this.options, translationInfo);
		
		//thisOptions.translationPair = translationInfo.translationPair;
		//thisOptions.translationInfo = translationInfo.translationInfo;
		console.warn("Sending option to parser : ", thisData.path, thisOptions);
		if (thisData.extension == "mps") {
			thisData.originalFormat = "WRPGE Map File"
			thisData.wolfFile = new WolfMap(thisFile, this.writeMode, thisOptions)
		} else if (thisData.basename == "CommonEvent.dat") {
			thisData.originalFormat = "WRPGE Common Event DAT File"
			thisData.wolfFile = new WolfCEFile(thisFile, this.writeMode, thisOptions)
		} else if (thisData.basename == "Game.dat") {
			thisData.originalFormat = "WRPGE Game.dat File"
			thisData.wolfFile = new WolfGameDatFile(thisFile, this.writeMode, thisOptions)
		} else if (thisData.extension == "dat") {
			thisData.originalFormat = "WRPGE Database File"
			thisData.wolfFile = new WolfDatFile(thisFile, this.writeMode, thisOptions)
		}
		
		this.files[thisData.path] = thisData;
	}
}




//var wolfMap = new WolfMap('F:\\test\\Wolf\\WRPGE\\Data\\MapData\\Map006.mps');
var testRoute
var doCheck = function() {
	
	testRoute = new WolfMap('F:\\test\\Wolf\\akaUsagi\\Data\\MapData\\Map000.mps', true, {
		'translationPair':translationPair
	});
	//console.log(testRoute);
	//console.log(testRoute.wolfEvents.events[0].page[0].commands);
}

var testEvt
var doCheck = function() {
	testEvt = new WolfMap('F:\\test\\Wolf\\WRPGE2\\Data\\MapData\\Map006_A.mps', true, {
		'translationPair':translationPair
	});
	console.log(testEvt);
	//console.log(testRoute.wolfEvents.events[0].page[0].commands);
}

var testJp = function() {
	var testJp = new WolfMap('F:\\test\\Wolf\\akaUsagi\\Data\\MapData\\Map000.mps');
	//console.log(testJp);
}

var commonEvents;
var testCE = function() {
	commonEvents = new WolfCEFile('F:\\test\\Wolf\\WRPGE2\\Data\\BasicData\\CommonEvent.dat', true, {
		'translationPair':translationPair
	});
	console.log(commonEvents);
	
	//console.log("write translation");
	commonEvents.wolfData.write('F:\\test\\Wolf\\WRPGE2\\Data\\BasicData\\CommonEvent.trans.dat');
}


var commonEvents2;
var testCE2 = function() {
	commonEvents2 = new WolfCEFile('F:\\test\\Wolf\\akausagi2\\Data\\BasicData\\CommonEvent.dat', true, {
		'translationPair':translationPair,
		'stringEncoding': 'Windows-31j'
	});
	console.log(commonEvents2);
	
	//console.log("write translation");
	commonEvents2.wolfData.write('F:\\test\\Wolf\\akausagi2\\Data\\BasicData\\CommonEvent.trans.dat');
}

var userData;
var testDB = function() {
	userData = new WolfDatFile('F:\\test\\Wolf\\WRPGE\\Data\\BasicData\\CDataBase.dat', true, {
		'translationPair':translationPair
	});
	//console.log(userData);
	
	//console.log("write translation");
	userData.wolfData.write('F:\\test\\Wolf\\WRPGE\\Data\\BasicData\\CDataBase.trans.dat');
}

var gemeDat;
var parseGameDat = function() {
	gemeDat = new WolfGameDatFile('F:\\test\\Wolf\\WRPGE\\Data\\BasicData\\Game.dat', true, {
		'translationPair':translationPair
	});
	console.log(gemeDat);
	
	//console.log("write translation");
	//gemeDat.wolfData.write('F:\\test\\Wolf\\WRPGE\\Data\\BasicData\\Game.trans.dat');
}


var wolfJs = "";
window.testWolfJs = function() {
	//wolfJs = new WolfJs('F:\\test\\Wolf\\gekituku\\extracted', true, {
	window.wolfJs = new WolfJs('F:\\test\\Wolf\\AkaUsagi02', true, {
		'translationPair':translationPair,
		'groupType' : 1
	});
	console.log(wolfJs);
}

console.clear();
//testDB();

//doCheck();
//testJp();
//parseGameDat();
//testWolfJs();
//console.log("Dump result : ", wolfJs.dump());


window.WolfJs = WolfJs;


var createNewProject = function(sourceDir, options) {
	options = options || {}
	var projectId 		= common.makeid(10);
	var path 		= require('path');
	var copydir 	= require('copy-dir');
	//var sourceDir 	= 'F:/test/Wolf/あかうさぎ2';
	var targetDir 	= nw.process.env.TMP+'\\'+projectId;
	var exePath 	= __dirname+"/3rdParty/wolfDec/WolfDec.exe"
	fs.mkdirSync(targetDir, {recursive:true});

	ui.loadingProgress(100, "Source directory is : "+sourceDir, {consoleOnly:true, mode:'consoleOutput'});

	copydir.sync(sourceDir, targetDir, {
	  filter: function(stat, filepath, filename){
		if(stat === 'directory') {
			return true;
		} else if(stat === 'file' && path.extname(filepath) === '.mps') {
			console.log("mps file found, copying");
			ui.loadingProgress(100, "Copying : "+filepath, {consoleOnly:true, mode:'consoleOutput'});
			
			return true;
		} else if(stat === 'file' && path.extname(filepath) === '.dat') {
			console.log("dat file found, copying");
			ui.loadingProgress(100, "Copying : "+filepath, {consoleOnly:true, mode:'consoleOutput'});
			
			return true;
		} else if(stat === 'file' && path.extname(filepath) === '.wolf') {
			console.log("wolf file found, copying");
			ui.loadingProgress(100, "Copying : "+filepath, {consoleOnly:true, mode:'consoleOutput'});
			
			return true;
		} 
		return false;
	  }
	});
	
	ui.loadingProgress(100, "Extracting wolf file", {consoleOnly:true, mode:'consoleOutput'});

	var files = common.getAllFiles(targetDir)
	var spawnSync = require('child_process').spawnSync;

	for (var i=0; i<files.length; i++) {
		var thisFile = files[i]
		if (path.extname(thisFile).toLowerCase() !== '.wolf') continue;
		ui.loadingProgress(0, "Extracting "+thisFile, {consoleOnly:true, mode:'consoleOutput'});
		console.log("processing ", thisFile);
		var result = spawnSync(exePath, [thisFile]);
		console.log("Done extracting ", thisFile);
		console.log(result);
	}
	var stagePath = common.getStagePath()+"/"+projectId;
	copydir.sync(targetDir, stagePath, {
	  filter: function(stat, filepath, filename){
		if(stat === 'directory') {
			return true;
		} else if(stat === 'file' && path.extname(filepath) === '.mps') {
			console.log("mps file found, copying");
			ui.loadingProgress(0, "Copying : "+filepath, {consoleOnly:true, mode:'consoleOutput'});
			
			return true;
		} else if(stat === 'file' && path.extname(filepath) === '.dat') {
			console.log("dat file found, copying");
			ui.loadingProgress(0, "Copying : "+filepath, {consoleOnly:true, mode:'consoleOutput'});
			
			return true;
		} 
		return false;
	  }
	});

	console.log("preparation done, parsing");
	ui.loadingProgress(0, "Preparation done!", {consoleOnly:true, mode:'consoleOutput'});
	ui.loadingProgress(0, "Parsing wolf files", {consoleOnly:true, mode:'consoleOutput'});
	
	var wolfJs = new WolfJs(targetDir, false, {
			'groupType' : 1
		});
	var transData = wolfJs.dump()
	transData.project.projectId = projectId;
	transData.project.cache = transData.project.cache||{};
	transData.project.cache.cachePath = common.getStagePath()+"/"+projectId;
	
	// 
	var gameInfo = {
		title : transData.project.gameTitle
	}
	
	fs.writeFileSync(transData.project.cache.cachePath+"/gameInfo.json", JSON.stringify(gameInfo, undefined, 2))
	
	
	ui.loadingProgress(0, "Parsing done!", {consoleOnly:true, mode:'consoleOutput'});
	ui.loadingProgress(0, "Creating new Project.", {consoleOnly:true, mode:'consoleOutput'});
	trans.openFromTransObj(transData, {isNew:true});
	ui.loadingProgress(0, "All done", {consoleOnly:true, mode:'consoleOutput'});
	ui.loadingEnd(100, "Done");
	trans.autoSave();
	ui.showCloseButton();

}

var exportWolfToFolder = function(sourceDir, targetDir, transData, options) {
	options = options||{};
	transData = transData || trans.getSaveData();
	var translationData = trans.getTranslationData( transData, {groupIndex:"relPath"});
	console.log("translation Data : ", translationData);
	var wolfJs = new WolfJs(sourceDir, true, {
		'translationData':translationData,
		'groupType' : 1
	});	
	wolfJs.writeToFolder(targetDir);
	
}


var init = function() {
	var $slide = $(`
		<h1><i class="icon-plus-circled"></i>Wolf RPG Editor games</h1>
		<div class="fieldgroup">
			<div class="blockBox attentionBlock withIcon">
			Do you plan to work with Wolf RPG game?<br />
			Translator++ may not support the latest version of Wolf RPG game.
			</div>
			<div class="actionButtons">
			</div>
		</div>			
			`);
	var $button = $('<button class="btnSelectExe selectRPGExe"><i class="icon-doc-inv"></i>Select executable file from your the game</button>')
	$button.on('click', function() {
		ui.openFileDialog({
			accept:".exe",
			onSelect : function(path) {
				//alert(path);
				ui.showLoading();
				var selectedDir = common.getDirectory(path);
				ui.loadingProgress(0, "Processing : "+selectedDir, {consoleOnly:true, mode:'consoleOutput'});
				ui.loadingProgress(0, "Please wait! The Window will appear like it's hang up for a large game. It is normal.", {consoleOnly:true, mode:'consoleOutput'});
				
				ui.newProjectDialog.close()
				setTimeout(function() {
					createNewProject(selectedDir);
				}, 500);
			}
		})		
	})
	$slide.find(".actionButtons").append($button);
	
	ui.newProjectDialog.addMenu({
		icon : "addons/wolfJs/icon.png",
		descriptionBar : `<h2>Wolf RPG</h2>
						<p>Translate from WRPG games with WolfJs</p>`,
		actionBar: "",
		goToSlide: 50,
		at:2,
		slides : {
			50: $slide
		}
	})

	if (typeof window.engines.wolf == 'undefined') engines.add('wolf');
	engines.wolf.addProperty('exportHandler', function(targetPath, options) {
		console.log("Path is : ", targetPath);
		console.log("options are : ", options);
		console.log(arguments);
		
		try {
			var pathStat = fs.lstatSync(targetPath)
			
			if (pathStat.isDirectory()) {
				exportWolfToFolder(trans.project.cache.cachePath, targetPath);
				return;
			}
		} catch (e) {
			
		}
		
		// is file
		var tmpPath = nw.process.env.TMP+"/"+trans.project.projectId;
		
		try {
			fs.mkdirSync(tmpPath, {recursive:true});
		} catch(e) {
			console.warn("Unable to create directory ", tmpPath);
			throw(e);
			return;
		}
		exportWolfToFolder(trans.project.cache.cachePath, tmpPath);
		var _7z = require('7zip-min');
		_7z.cmd(['a', '-tzip', targetPath, tmpPath+'/Data'], err => {
			// done
			console.log("process done");
		});
	});

}

$(document).ready(function() {
	ui.onReady(function() {
		init();
	});
});
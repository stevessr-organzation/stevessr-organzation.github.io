"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextProcessorRowLine = void 0;
const TextProcessor_1 = require("./TextProcessor");
const _Constants_1 = require("./_Constants");
class TextProcessorRowLine {
    constructor(process, text) {
        this.parts = [];
        this.symbols = [];
        this.placeholders = [];
        this.placeholdersPositions = [];
        this.placeholderIndexFromMatch = {};
        this.placeholderContent = {};
        this.placeholderCount = 0;
        this.extractedStrings = [];
        this.translations = [];
        this.expecting = 0;
        this.isScript = false;
        this.quoteType = '"';
        this.processed = false;
        this.passes = {};
        this.broken = false;
        this.process = process;
        this.originalString = text;
        for (let key in _Constants_1.TextProcessorOrderType) {
            this.passes[key] = 0;
        }
    }
    getProcessingOrder() {
        return this.process.getProcessor().getProcessingOrder();
    }
    storeSymbol(text) {
        return this.symbols.push(text) - 1;
    }
    hasPlaceholder(match) {
        return typeof this.placeholderIndexFromMatch[match] != 'undefined';
    }
    getPlaceholder(match) {
        return this.placeholders[this.placeholderIndexFromMatch[match]];
    }
    isolateSymbols() {
        let patterns = this.getIsolatePatterns();
        this.replaceAll(true, patterns, (match, originalIndex) => {
            let placeholder = this.createPlaceholder(match, originalIndex);
            this.placeholderContent[placeholder] = new TextProcessorRowLine(this.process, match);
            this.extractedStrings.push(this.placeholderContent[placeholder]);
            return placeholder;
        }, this.passes[_Constants_1.TextProcessorOrderType.ISOLATE_SENTENCES]++);
    }
    protectCorners() {
        let patterns = this.getProtectCornersPatterns();
        this.matchAll(patterns, (matching, match) => {
            return [this.storeSymbol(match[0])];
        }, this.passes[_Constants_1.TextProcessorOrderType.CUT_CORNERS]++);
    }
    breakLines() {
        let patterns = this.getLineBreakPatterns();
        let splitsOn = [];
        this.matchAll(patterns, (matching, match) => {
            let idx = this.storeSymbol(this.getLineBreakReplacement());
            splitsOn.push(idx);
            return [idx];
        }, this.passes[_Constants_1.TextProcessorOrderType.BREAK_LINES]++);
        // By isolating them into separate TextProcessorRowLine we can reduce placeholder count, which results in better translations.
        splitsOn.forEach((index) => {
            [-1, 1].forEach((direction) => {
                if (typeof this.parts[index + direction] == 'string') {
                    this.parts[index + direction] = this.storeSymbol(new TextProcessorRowLine(this.process, this.parts[index + direction]));
                    this.extractedStrings.push(this.symbols[this.parts[index + direction]]);
                }
            });
        });
    }
    splitSentences() {
        let patterns = this.getSplittingPatterns();
        // Our matchAll function won't work here... or would it?
        let splitsOn = [];
        this.matchAll(patterns, (matching, match) => {
            let idx = this.storeSymbol(match[0]);
            splitsOn.push(idx);
            return [idx];
        }, this.passes[_Constants_1.TextProcessorOrderType.AGGRESSIVE_SPLITTING]++);
        if (this.isSplittingTranslatable()) {
            for (let i = this.parts.length - 1; i >= 0; i--) {
                let part = this.parts[i];
                if (typeof part == 'number' && splitsOn.indexOf(part) != -1) {
                    let originalText = this.symbols[part];
                    if (this.isSplittingIncludedOnNext()) {
                        let nextPart = this.parts[i + 1];
                        if (typeof nextPart == 'string') {
                            this.parts[i + 1] = originalText + nextPart;
                            // Remove the index
                            this.parts.splice(i, 1);
                        }
                    }
                    else {
                        let previousPart = this.parts[i - 1];
                        if (typeof previousPart == 'string') {
                            this.parts[i - 1] = previousPart + originalText;
                            // Remove the index
                            this.parts.splice(i, 1);
                        }
                    }
                }
            }
        }
    }
    escapeSymbols() {
        let patterns = this.getEscapePatterns();
        this.replaceAll(false, patterns, (match, originalIndex) => {
            let placeholder = this.createPlaceholder(match, originalIndex);
            return placeholder;
        }, this.passes[_Constants_1.TextProcessorOrderType.ESCAPE_SYMBOLS]++);
    }
    mergeSequentialSymbols() {
        let pattern = _Constants_1.PlaceholderTypeRegExp[this.getPlaceholderType()];
        if (typeof pattern == 'undefined') {
            // Do not report this to the Process - this is spam and should only happen with invalid placeholder type.
            console.warn('[TextProcessorRowLine] 已请求合并顺序符号，但没有可用于的模式 ' +
                this.getPlaceholderType);
        }
        else {
            let regexPattern = new RegExp(`(\\s*${pattern}\\s*){2,}`, 'g');
            this.replaceAll(false, [regexPattern], (match, originalIndex) => {
                let placeholder = this.createPlaceholder(match, originalIndex);
                return placeholder;
            }, 0);
        }
    }
    protectPureSymbols() {
        let pattern = _Constants_1.PlaceholderTypeRegExp[this.getPlaceholderType()];
        if (typeof pattern == 'undefined') {
            // Do not report this to the Process - this is spam and should only happen with invalid placeholder type.
            console.warn('[TextProcessorRowLine] 没有可用的图案 ' + this.getPlaceholderType);
        }
        else {
            let padding = '[' + _Constants_1.symbolsSpaces + ']*';
            let regexPattern = new RegExp(`^(${padding + pattern + padding})+$`, 'g');
            for (let i = 0; i < this.parts.length; i++) {
                if (typeof this.parts[i] == 'string') {
                    let match = this.parts[i].match(regexPattern);
                    if (match != null) {
                        this.parts[i] = this.storeSymbol(this.parts[i]);
                    }
                }
            }
        }
    }
    regExpFromPattern(unfilteredPattern, options) {
        if (unfilteredPattern instanceof RegExp) {
            return unfilteredPattern;
        }
        else if (Array.isArray(unfilteredPattern)) {
            let exps = [];
            unfilteredPattern.forEach((str) => {
                exps.push('(' + str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&') + ')');
            });
            return new RegExp(exps.join('|'), 'gi');
        }
        else if (typeof unfilteredPattern == 'function') {
            return this.regExpFromPattern(unfilteredPattern(options), options);
        }
    }
    matchAll(patterns, onMatch, pass) {
        let found = true;
        while (found) {
            found = false;
            for (let patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
                for (let textIndex = this.parts.length - 1; textIndex >= 0; textIndex--) {
                    if (typeof this.parts[textIndex] != 'string') {
                        continue;
                    }
                    let pattern = this.regExpFromPattern(patterns[patternIndex], {
                        fullString: this.parts[textIndex],
                        pass: pass
                    });
                    if (pattern == undefined) {
                        continue;
                    }
                    let matching = {
                        text: this.parts[textIndex],
                        resultingArray: [],
                        matches: [...this.parts[textIndex].matchAll(pattern)],
                        startPosition: 0
                    };
                    matching.matches.forEach((match) => {
                        found = true;
                        let line = matching.text.substring(matching.startPosition, match.index);
                        let lineBreak = match[0];
                        let length = lineBreak.length;
                        matching.startPosition = match.index + length;
                        if (line.length > 0)
                            matching.resultingArray.push(line);
                        matching.resultingArray.push(...onMatch(matching, match));
                    });
                    // Did we get everything?
                    if (matching.startPosition < matching.text.length) {
                        matching.resultingArray.push(matching.text.substring(matching.startPosition));
                    }
                    this.parts[textIndex] = matching.resultingArray[0];
                    for (let i = 1; i < matching.resultingArray.length; i++) {
                        this.parts.splice(textIndex + i, 0, matching.resultingArray[i]);
                    }
                }
            }
        }
    }
    getOriginalIndex(text, match, position) {
        let originalIndex;
        if (position == undefined) {
            position = text.indexOf(match);
        }
        if (position == 0) {
            originalIndex = 0; // start of sentence
        }
        else if (match.length + position == text.length) {
            originalIndex = 1; // end of sentence
        }
        else {
            originalIndex = (match.length / 2 + position) / text.length; // "somewhere around the middle"
        }
        return originalIndex;
    }
    getOriginalIndexTransformed(text, originalIndex) {
        // given a position bigger than 0 and smaller than 1, find ideal spot to place it into text
        let spotOn = originalIndex * text.length;
        let spaces = [];
        for (let i = 0; i < text.length; i++) {
            if (text.charAt(i) == ' ') {
                spaces.push(i);
            }
        }
        if (spaces.length == 0) {
            // we are using a language without spaces. Just throw it in there who cares.
            return Math.floor(spotOn);
        }
        else {
            let bestDistance = spotOn;
            let bestIndex = 0;
            for (let i = 0; i < spaces.length; i++) {
                let distance = Math.abs(spaces[i] - spotOn);
                if (distance < bestDistance) {
                    bestIndex = spaces[i];
                    bestDistance = distance;
                }
            }
            return bestIndex;
        }
    }
    replaceAll(translatable, patterns, replacer, pass) {
        let found = true;
        while (found) {
            found = false;
            for (let patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
                for (let textIndex = this.parts.length - 1; textIndex >= 0; textIndex--) {
                    if (typeof this.parts[textIndex] != 'string') {
                        continue;
                    }
                    let text = this.parts[textIndex];
                    let pattern = this.regExpFromPattern(patterns[patternIndex], {
                        fullString: text,
                        pass: pass
                    });
                    if (pattern == undefined) {
                        continue;
                    }
                    let matches = [...text.matchAll(pattern)];
                    for (let i = matches.length - 1; i >= 0; i--) {
                        let match = matches[i];
                        if (match.index == 0 && match[0].length == text.length) {
                            if (!translatable) {
                                this.parts[textIndex] = this.storeSymbol(text); // will only have one match, so no need to break
                            }
                        }
                        else {
                            found = true;
                            let originalIndex = this.getOriginalIndex(text, match[0], match.index);
                            text =
                                text.substring(0, match.index) +
                                    replacer(match[0], originalIndex) +
                                    text.substring(match.index + match[0].length);
                        }
                    }
                    if (typeof this.parts[textIndex] == 'string') {
                        this.parts[textIndex] = text;
                    }
                }
            }
        }
    }
    /**
     * Stores a string and returns a placeholder.
     * @param match The matching text.
     * @param originalIndex From 0 to 1, the position of the placeholder in the original string.
     * @returns
     */
    createPlaceholder(match, originalIndex) {
        // Is this a symbol we already have?
        let existingIndex = this.placeholderIndexFromMatch[match];
        if (typeof existingIndex != 'undefined') {
            let placeholder = this.placeholders[existingIndex];
            this.placeholders.push(placeholder);
            this.placeholdersPositions.push(originalIndex);
            return placeholder;
        }
        let creator = _Constants_1.PlaceholderCreator[this.getPlaceholderType()];
        // Is the placeholdertype valid?
        if (typeof creator == 'undefined') {
            this.process.addWarning({
                message: '[TextProcessorRowLine] 提供的占位符类型无效 - ' +
                    this.getPlaceholderType() +
                    '。无法逃脱。',
                originalSentence: this.originalString
            });
            return match;
        }
        // Everything is right in the world
        let count = this.placeholderCount++;
        let placeholder = creator(count);
        if (this.isEscapePatternPad()) {
            placeholder = ' ' + placeholder + ' ';
        }
        this.placeholderIndexFromMatch[match] = this.placeholders.push(placeholder) - 1;
        this.placeholdersPositions.push(originalIndex);
        this.placeholderContent[placeholder] = match;
        return placeholder;
    }
    getTranslatableStrings() {
        this.init();
        let strings = [];
        // My own strings
        for (let i = 0; i < this.parts.length; i++) {
            if (typeof this.parts[i] == 'string') {
                strings.push(this.parts[i]);
            }
        }
        // Strings from what I extracted
        for (let i = 0; i < this.extractedStrings.length; i++) {
            strings.push(...this.extractedStrings[i].getTranslatableStrings());
        }
        this.expecting = strings.length;
        return strings;
    }
    addTranslations(...translations) {
        if (this.translations.length + translations.length > this.expecting) {
            throw new Error('翻译太多。预期的 ' +
                this.expecting +
                '，但已收到 ' +
                (this.translations.length + translations.length));
        }
        this.translations.push(...translations);
    }
    isDone() {
        return this.translations.length == this.expecting;
    }
    applyTranslations() {
        let innerIndex = 0;
        let currentPart = this.parts[innerIndex];
        let extractedIndex = 0;
        let currentExtracted = this.extractedStrings[extractedIndex];
        for (let i = 0; i < this.translations.length; i++) {
            if (typeof this.translations[i] != 'string') {
                this.broken = true;
            }
            while (typeof currentPart == 'number') {
                currentPart = this.parts[++innerIndex];
            }
            if (typeof currentPart == 'undefined') {
                // start applying to extracteds
                while (typeof currentExtracted != 'undefined' && currentExtracted.isDone()) {
                    currentExtracted = this.extractedStrings[++extractedIndex];
                }
                currentExtracted.addTranslations(this.translations[i]);
            }
            else {
                this.parts[innerIndex] = this.translations[i];
                currentPart = this.parts[++innerIndex];
            }
        }
    }
    init() {
        if (this.processed) {
            return;
        }
        let text = this.originalString;
        if (this.isTrim()) {
            text = text.trim();
        }
        if (this.isMaintainScripts()) {
            let trim = text.trim();
            // Ideally we would do something like a JSON.parse, but just because it is a literal string doesn't mean it is a valid JSON string.
            // Depending on the source of the original text, it might have invalid stuff like \C or \V (RPG Maker).
            if (['"', "'"].indexOf(trim.charAt(0)) != -1 &&
                trim.charAt(trim.length - 1) == trim.charAt(0)) {
                this.isScript = true;
                this.quoteType = trim.charAt(0);
                text = trim.substring(1, trim.length - 1);
            }
        }
        this.parts = [text];
        let order = this.getProcessingOrder();
        order.forEach((action) => {
            switch (action) {
                case _Constants_1.TextProcessorOrderType.BREAK_LINES:
                    this.breakLines();
                    break;
                case _Constants_1.TextProcessorOrderType.ESCAPE_SYMBOLS:
                    this.escapeSymbols();
                    break;
                case _Constants_1.TextProcessorOrderType.ISOLATE_SENTENCES:
                    this.isolateSymbols();
                    break;
                case _Constants_1.TextProcessorOrderType.AGGRESSIVE_SPLITTING:
                    this.splitSentences();
                    break;
                case _Constants_1.TextProcessorOrderType.CUT_CORNERS:
                    this.protectCorners();
                    break;
            }
        });
        if (this.isTrimLines()) {
            for (let i = 0; i < this.parts.length; i++) {
                if (typeof this.parts[i] == 'string') {
                    let lines = this.parts[i].split('\n');
                    for (let k = 0; k < lines.length; k++) {
                        lines[k] = lines[k].trim();
                    }
                    this.parts[i] = lines.join('\n');
                }
            }
        }
        if (this.isMergeSequentialSymbols()) {
            this.mergeSequentialSymbols();
        }
        this.protectPureSymbols();
        this.processed = true;
    }
    getTranslatedString() {
        if (this.translations.length != this.expecting) {
            throw new Error('没有收到足够的翻译。预期的 ' +
                this.expecting +
                '，但已收到 ' +
                this.translations.length);
        }
        this.applyTranslations();
        if (this.broken) {
            return undefined;
        }
        let finalString = '';
        for (let i = 0; i < this.parts.length; i++) {
            if (typeof this.parts[i] == 'number') {
                let symbol = this.symbols[this.parts[i]];
                if (typeof symbol == 'string') {
                    finalString += symbol;
                }
                else {
                    let content = symbol.getTranslatedString();
                    if (content === undefined) {
                        this.broken = true;
                        return undefined;
                    }
                    finalString += content;
                }
            }
            else {
                finalString += this.parts[i];
            }
        }
        for (let i = this.placeholders.length - 1; i >= 0; i--) {
            let originalIndex = this.placeholdersPositions[i];
            let placeholder = this.placeholders[i];
            let content = this.placeholderContent[placeholder];
            if (typeof content != 'string') {
                content = content.getTranslatedString();
                if (typeof content == 'undefined') {
                    this.broken = true;
                    return undefined;
                }
            }
            let idx = finalString.lastIndexOf(placeholder);
            if (idx == -1) {
                // This might result in a lower quality result (might have extra padding etc), so a last resort.
                placeholder = placeholder.trim().toLowerCase();
                let lower = finalString.toLowerCase();
                idx = lower.lastIndexOf(placeholder);
            }
            if (idx == -1) {
                let recoveryType = this.process.getProcessor().getRecoveryType();
                let message = '把它忘了。';
                switch (recoveryType) {
                    case TextProcessor_1.PlaceholderRecoveryType.ADD_AT_END:
                        (message = '在末尾添加了它。'), (finalString += ' ' + content);
                        break;
                    case TextProcessor_1.PlaceholderRecoveryType.ADD_AT_START:
                        (message = '在开头添加了它。'),
                            (finalString = content + ' ' + finalString);
                        break;
                    case TextProcessor_1.PlaceholderRecoveryType.GUESS:
                        if (originalIndex == 0) {
                            (message = '在一开始就添加了它，因为它最初就在那里。'),
                                (finalString = content + ' ' + finalString);
                        }
                        else if (originalIndex == 1) {
                            (message = '在末尾添加它，因为它最初就在那里。'),
                                (finalString += ' ' + content);
                        }
                        else {
                            let idealIndex = this.getOriginalIndexTransformed(finalString, originalIndex);
                            message = `将其添加到 ${idealIndex} 位置，因为它最接近原始位置。`;
                            finalString =
                                finalString.substring(0, idealIndex) +
                                    ` ${content} ` +
                                    finalString.substring(idealIndex + 1);
                        }
                        break;
                }
                this.process.addWarning({
                    message: `[TextProcessorRowLine] 无法恢复占位符: ${placeholder}. ${message}`,
                    originalSentence: this.originalString,
                    currentSentence: finalString,
                    placeholders: this.placeholders
                });
            }
            else {
                finalString =
                    finalString.substring(0, idx) +
                        content +
                        finalString.substring(idx + placeholder.length);
            }
        }
        if (this.isScript) {
            finalString = finalString.replaceAll(new RegExp(this.quoteType, 'g'), '\\' + this.quoteType);
            finalString = this.quoteType + finalString + this.quoteType;
        }
        if (this.isRecoverPadding()) {
            let explodedOriginal = this.originalString.split(/\r?\n/g);
            let explodedFinalString = finalString.split(/\r?\n/g);
            function getLastPad(i) {
                while (typeof explodedOriginal[i] == 'undefined' && i > 0) {
                    i--;
                }
                if (typeof explodedOriginal[i] == 'undefined') {
                    return '';
                }
                else {
                    let line = explodedOriginal[i];
                    let padRegExp = new RegExp(`^[${_Constants_1.symbolsSpaces}]+`);
                    let match = line.match(padRegExp);
                    if (match != null) {
                        return match[0];
                    }
                    else {
                        return '';
                    }
                }
            }
            for (let i = 0; i < explodedFinalString.length; i++) {
                explodedFinalString[i] = getLastPad(i) + explodedFinalString[i];
            }
            finalString = explodedFinalString.join('\n');
        }
        return finalString;
    }
    getIsolatePatterns() {
        return this.process.getProcessor().getIsolatePatterns();
        //return [/(\()(.+?)(\))/g];
    }
    getEscapePatterns() {
        return this.process.getProcessor().getEscapePatterns();
        //return [/(\\C\[\d+\])+/g];
    }
    getSplittingPatterns() {
        return this.process.getProcessor().getAggressiveSplittingPatterns();
        //return [/( *\r?\n *){2,}/g];
    }
    isSplittingTranslatable() {
        return this.process.getProcessor().isAggressiveSplittingTranslatable();
        //return false;
    }
    isSplittingIncludedOnNext() {
        return this.process.getProcessor().isAggressiveSplittingNext();
        //return false;
    }
    isMergeSequentialSymbols() {
        return this.process.getProcessor().isMergeSequentialSymbols();
        //return true;
    }
    isEscapePatternPad() {
        return this.process.getProcessor().isEscapePatternPad();
        //return true;
    }
    isMaintainScripts() {
        return this.process.getProcessor().isMaintainScripts();
        //return true;
    }
    isRecoverPadding() {
        return this.process.getProcessor().isRecoverPadding();
    }
    isTrim() {
        return this.process.getProcessor().isTrim();
    }
    isTrimLines() {
        return this.process.getProcessor().isTrimLines();
    }
    getLineBreakPatterns() {
        return this.process.getProcessor().getLineBreakPatterns();
        //return [/(\r?\n *\r?\n)/g];
    }
    getLineBreakReplacement() {
        return this.process.getProcessor().getLineBreakReplacement();
        //return "\n\n";
    }
    getProtectCornersPatterns() {
        return this.process.getProcessor().getProtectCornersPatterns();
        //return [/(^ *\{\{\d+\}\} *)|( *\{\{\d+\}\} *$)|(^\()|(\)$)/g];
    }
    getPlaceholderType() {
        return this.process.getProcessor().getPlaceholderType();
        //return PlaceholderType.doubleCurlie;
    }
}
exports.TextProcessorRowLine = TextProcessorRowLine;

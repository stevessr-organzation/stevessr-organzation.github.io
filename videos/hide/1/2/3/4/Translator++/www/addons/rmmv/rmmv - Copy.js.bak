var thisAddon 	= this;
var appName 	= this.package.name;
var spawn 		= spawn || require('child_process').spawn;
var ws 			= ws || require('windows-shortcuts');
var ini 		= ini || require('ini')
var bCopy 		= require('better-copy');
var fse 		= require('fs-extra');


class RMMVData extends require("www/js/ParserBase.js").ParserBase {
	constructor(obj, options, callback) {
		super(obj, options, callback)
		this.debugLevel = 9;
		this.currentEntryPoint = {};
	}
}
RMMVData['RPGM_EVENT_CODE'] = {};
RMMVData['RPGM_EVENT_CODE'][0]="Empty";
RMMVData['RPGM_EVENT_CODE'][101]="Show Text Attributes";
RMMVData['RPGM_EVENT_CODE'][102]="Show Choices";
RMMVData['RPGM_EVENT_CODE'][103]="Input Number";
RMMVData['RPGM_EVENT_CODE'][104]="Select Key Item";
RMMVData['RPGM_EVENT_CODE'][105]="Show Scrolling Text Attributes";
RMMVData['RPGM_EVENT_CODE'][108]="Comment";
RMMVData['RPGM_EVENT_CODE'][111]="Conditional Branch";
RMMVData['RPGM_EVENT_CODE'][112]="Loop";
RMMVData['RPGM_EVENT_CODE'][113]="Break Loop";
RMMVData['RPGM_EVENT_CODE'][115]="Exit Event Processing";
RMMVData['RPGM_EVENT_CODE'][117]="Call Common Event";
RMMVData['RPGM_EVENT_CODE'][118]="Label";
RMMVData['RPGM_EVENT_CODE'][119]="Jump to Label";
RMMVData['RPGM_EVENT_CODE'][121]="Control Switches";
RMMVData['RPGM_EVENT_CODE'][122]="Control Variables";
RMMVData['RPGM_EVENT_CODE'][123]="Control Self Switch";
RMMVData['RPGM_EVENT_CODE'][124]="Control Timer";
RMMVData['RPGM_EVENT_CODE'][125]="Change Gold";
RMMVData['RPGM_EVENT_CODE'][126]="Change Items";
RMMVData['RPGM_EVENT_CODE'][127]="Change Weapons";
RMMVData['RPGM_EVENT_CODE'][128]="Change Armor";
RMMVData['RPGM_EVENT_CODE'][129]="Change Party Member";
RMMVData['RPGM_EVENT_CODE'][132]="Change Battle BGM";
RMMVData['RPGM_EVENT_CODE'][133]="Change Battle End ME";
RMMVData['RPGM_EVENT_CODE'][134]="Change Save Access";
RMMVData['RPGM_EVENT_CODE'][135]="Change Menu Access";
RMMVData['RPGM_EVENT_CODE'][136]="Change Encounter";
RMMVData['RPGM_EVENT_CODE'][137]="Change Formation Access";
RMMVData['RPGM_EVENT_CODE'][138]="Change Window Color";
RMMVData['RPGM_EVENT_CODE'][201]="Transfer Player";
RMMVData['RPGM_EVENT_CODE'][202]="Set Vehicle Location";
RMMVData['RPGM_EVENT_CODE'][203]="Set Event Location";
RMMVData['RPGM_EVENT_CODE'][204]="Scroll Map";
RMMVData['RPGM_EVENT_CODE'][205]="Set Move Route";
RMMVData['RPGM_EVENT_CODE'][206]="Get on/off Vehicle";
RMMVData['RPGM_EVENT_CODE'][211]="Change Transparency";
RMMVData['RPGM_EVENT_CODE'][212]="Show Animation";
RMMVData['RPGM_EVENT_CODE'][213]="Shot Balloon Icon";
RMMVData['RPGM_EVENT_CODE'][214]="Erase Event";
RMMVData['RPGM_EVENT_CODE'][216]="Change Player Followers";
RMMVData['RPGM_EVENT_CODE'][217]="Gather Followers";
RMMVData['RPGM_EVENT_CODE'][221]="Fadeout Screen";
RMMVData['RPGM_EVENT_CODE'][222]="Fadein Screen";
RMMVData['RPGM_EVENT_CODE'][223]="Tint Screen";
RMMVData['RPGM_EVENT_CODE'][224]="Flash Screen";
RMMVData['RPGM_EVENT_CODE'][225]="Shake Screen";
RMMVData['RPGM_EVENT_CODE'][230]="Wait";
RMMVData['RPGM_EVENT_CODE'][231]="Show Picture";
RMMVData['RPGM_EVENT_CODE'][232]="Move Picture";
RMMVData['RPGM_EVENT_CODE'][233]="Rotate Picture";
RMMVData['RPGM_EVENT_CODE'][234]="Tint Picture";
RMMVData['RPGM_EVENT_CODE'][235]="Erase Picture";
RMMVData['RPGM_EVENT_CODE'][236]="Set Weather Effects";
RMMVData['RPGM_EVENT_CODE'][241]="Play BGM";
RMMVData['RPGM_EVENT_CODE'][242]="Fadeout BGM";
RMMVData['RPGM_EVENT_CODE'][243]="Save BGM";
RMMVData['RPGM_EVENT_CODE'][244]="Replay BGM";
RMMVData['RPGM_EVENT_CODE'][245]="Play BGS";
RMMVData['RPGM_EVENT_CODE'][246]="Fadeout BGS";
RMMVData['RPGM_EVENT_CODE'][249]="Play ME";
RMMVData['RPGM_EVENT_CODE'][250]="Play SE";
RMMVData['RPGM_EVENT_CODE'][251]="Stop SE";
RMMVData['RPGM_EVENT_CODE'][261]="Play Movie";
RMMVData['RPGM_EVENT_CODE'][281]="Change Map Display";
RMMVData['RPGM_EVENT_CODE'][282]="Change Tileset";
RMMVData['RPGM_EVENT_CODE'][283]="Change Battle Back";
RMMVData['RPGM_EVENT_CODE'][284]="Change Parallax Back";
RMMVData['RPGM_EVENT_CODE'][285]="Get Location Info";
RMMVData['RPGM_EVENT_CODE'][301]="Battle Processing";
RMMVData['RPGM_EVENT_CODE'][302]="Shop Processing";
RMMVData['RPGM_EVENT_CODE'][303]="Name Input Processing";
RMMVData['RPGM_EVENT_CODE'][311]="Change HP";
RMMVData['RPGM_EVENT_CODE'][312]="Change MP";
RMMVData['RPGM_EVENT_CODE'][313]="Change State";
RMMVData['RPGM_EVENT_CODE'][314]="Recover All";
RMMVData['RPGM_EVENT_CODE'][315]="Change EXP";
RMMVData['RPGM_EVENT_CODE'][316]="Change Level";
RMMVData['RPGM_EVENT_CODE'][317]="Change Parameters";
RMMVData['RPGM_EVENT_CODE'][318]="Change Skills";
RMMVData['RPGM_EVENT_CODE'][319]="Change Equipment";
RMMVData['RPGM_EVENT_CODE'][320]="Change Actor Name";
RMMVData['RPGM_EVENT_CODE'][321]="Change Actor Class";
RMMVData['RPGM_EVENT_CODE'][322]="Change Actor Graphic";
RMMVData['RPGM_EVENT_CODE'][323]="Change Vehicle Graphic";
RMMVData['RPGM_EVENT_CODE'][324]="Change Actor Nickname";
RMMVData['RPGM_EVENT_CODE'][325]="Change Actor Profile";
RMMVData['RPGM_EVENT_CODE'][331]="Change Enemy HP";
RMMVData['RPGM_EVENT_CODE'][332]="Change Enemy MP";
RMMVData['RPGM_EVENT_CODE'][333]="Change Enemy State";
RMMVData['RPGM_EVENT_CODE'][334]="Enemy Recover All";
RMMVData['RPGM_EVENT_CODE'][335]="Enemy Appear";
RMMVData['RPGM_EVENT_CODE'][336]="Enemy Transform";
RMMVData['RPGM_EVENT_CODE'][337]="Show Battle Animation";
RMMVData['RPGM_EVENT_CODE'][339]="Force Action";
RMMVData['RPGM_EVENT_CODE'][340]="Abort Battle";
RMMVData['RPGM_EVENT_CODE'][351]="Open Menu Screen";
RMMVData['RPGM_EVENT_CODE'][352]="Open Save Screen";
RMMVData['RPGM_EVENT_CODE'][353]="Game Over";
RMMVData['RPGM_EVENT_CODE'][354]="Return to Title Screen";
RMMVData['RPGM_EVENT_CODE'][355]="Script Header";
RMMVData['RPGM_EVENT_CODE'][356]="Plugin Command";
RMMVData['RPGM_EVENT_CODE'][401]="Show Text";
RMMVData['RPGM_EVENT_CODE'][402]="Choice";
RMMVData['RPGM_EVENT_CODE'][403]="Choice Cancel";
RMMVData['RPGM_EVENT_CODE'][404]="Choices End";
RMMVData['RPGM_EVENT_CODE'][405]="Show Scrolling Text";
RMMVData['RPGM_EVENT_CODE'][408]="Comment More";
RMMVData['RPGM_EVENT_CODE'][411]="Else";
RMMVData['RPGM_EVENT_CODE'][412]="Branch End";
RMMVData['RPGM_EVENT_CODE'][413]="Repeat Above";
RMMVData['RPGM_EVENT_CODE'][601]="If Win";
RMMVData['RPGM_EVENT_CODE'][602]="If Escape";
RMMVData['RPGM_EVENT_CODE'][603]="If Lose";
RMMVData['RPGM_EVENT_CODE'][604]="Battle Processing End";
RMMVData['RPGM_EVENT_CODE'][605]="Shop Item";
RMMVData['RPGM_EVENT_CODE'][655]="Script";

RMMVData.determineType = function($path) {
	var fileName = nwPath.basename($path, nwPath.extname($path));
	if (/Map[0-9]+/g.test(fileName)) {
		return "map"
	} else {
		return fileName.toLowerCase();
	}
}


RMMVData.prototype.MV_buildTextList = function($text, $header) {
	// $splitEach 0 ... then no split;
	// Show message are $splitEach = 4
	$text = $text.replaceAll("\r", "");
	var $textArray = $text.split("\n");
	
	var $LIST =[];
	for (var $key=0; $key<$textArray.length; $key++) { 
		var $line = $textArray[$key];
		if (($key+1)%4 == 1) {
			$LIST.push($header);
		}
		var $newRow = {};
		$newRow['code'] = 401;
		$newRow['indent'] = $header['indent'];
		$newRow['parameters'] = [$line];
		$LIST.push($newRow);
	}
	return $LIST;
}

RMMVData.prototype.MV_buildScrollTextList = function($text, $header) {
	$text = $text.replaceAll("\r", "");
	var $textArray = $text.split("\n");
	
	var $LIST =[];
	$LIST.push($header);
	for (var $key=0; $key<$textArray.length; $key++) { 
		var $line = $textArray[$key];
		var $newRow = [];
		$newRow['code'] = 401;
		$newRow['indent'] = $header['indent'];
		$newRow['parameters'] = [$line];
		$LIST.push($newRow);
	}
	return $LIST;
}


RMMVData.prototype.applyTranslation = function(translation, localContext, parameters, options) {
	console.log("Entering applyTranslation", arguments);
}

RMMVData.prototype.registerStringObject = function(obj, key, parameters, options) {
	var translation = this.registerString(obj[key], parameters, options);
	// apply translation
	obj[key] = translation;
	return translation;
}

RMMVData.prototype.registerString = function(string, localContext, parameters, options) {
	options = options || {};
	options.currentAddress = options.currentAddress || this.currentAddress;

	console.log("registering string:", arguments);

	var copyContext = JSON.parse(JSON.stringify(this.currentContext))
	localContext = localContext||[];
	if (Array.isArray(localContext) == false) localContext = [localContext];
	copyContext = copyContext.concat(localContext);

	var filteredText = this.filterText(string, copyContext, parameters)

	if (string.trim().length > 0) {
		this.translatableTexts.push({
			text:filteredText,
			rawText:string,
			context:copyContext,
			parameters:parameters,
			tags:options.tags||[],
			address:common.clone(options.currentAddress)
		});
	}
	
	var translation = this.translate(filteredText, copyContext);
	if (translation !== filteredText) {
		if (this.debugLevel >= 1) console.log("%cTranslating", 'background: #222; color: #bada55', filteredText,"->", translation, this.translationPair);
		
		this.writableData.push(this.unfilterText(translation, copyContext, parameters));
	} else {
		this.writableData.push(string);
	}
	return translation;
}

RMMVData.prototype.fetchCommonData = function($data, $fetchData, $parentContext, options) {
	options = options || {};
	options.currentAddress = options.currentAddress || [];
	console.log("parsing common data");
	if (empty($data)) return false;
	console.log("incoming data is:", $data);

	// create a copy of data;
	this.translatedData = common.clone($data);


	for ($i=1; $i<$data.length; $i++) {
		if (empty($data[$i])) continue;

		for ($fetch=0; $fetch<$fetchData.length; $fetch++) {
			if (!Boolean($data[$i][$fetchData[$fetch]])) continue; // will allow blank if only this
			if (empty($data[$i][$fetchData[$fetch]])) continue;
			//var context = common.clone($parentContext);
			//context.push($i, $fetchData[$fetch]);
			var context = $parentContext.concat([$i, $fetchData[$fetch]]);
			var thisCurrentAddress = options.currentAddress.concat([$i, $fetchData[$fetch]]);
			//this.registerString($data[$i][$fetchData[$fetch]], context, {});
			this.registerStringObject($data[$i], $fetchData[$fetch], context, [], {currentAddress:thisCurrentAddress})

		}
	}

	if (this.writeMode) this.writableObj = $data;
	return this;
}


/*
RMMVData.prototype.fetchCommonData = function($data, $fetchData, $parentContext = '') {
	if (empty($data)) return false;
	this.data = $data;
	var $RESULT = [];
	for ($i=1; $i<$data.length; $i++) {
		if (empty($data[$i])) continue;

		var $current = [];
		for ($fetch=0; $fetch<$fetchData.length; $fetch++) {
			if (!Boolean($data[$i][$fetchData[$fetch]])) continue; // will allow blank if only this
			if (empty($data[$i][$fetchData[$fetch]])) continue;
			
			if (!empty($RESULT[$data[$i][$fetchData[$fetch]]])) {
				$RESULT[$data[$i][$fetchData[$fetch]]]['context'].push($parentContext+"/"+$i+"/"+$fetchData[$fetch]);
			} else {
				var $thisObj = {};
				$thisObj['context'] = [];
				$thisObj['text'] = $data[$i][$fetchData[$fetch]];
				$thisObj['context'].push($parentContext+"/"+$i+"/"+$fetchData[$fetch]);
				$RESULT[$thisObj['text']] = $thisObj;
			}
		}
	}
	
	this.parsed = $RESULT;
	return this;
}
*/

RMMVData.prototype.fetchEventPages = function($eventPages, $parentContext, $RESULT = {}) {
	console.log("handling Event pages", arguments);
	if (!Array.isArray($eventPages)) return false;
	var $currentText = [];
	var $currentLongText = [];

	// create result
	var translatedPage = common.clone($eventPages);

	for(var $keyPage=0; $keyPage<$eventPages.length; $keyPage++) {
		var $page = $eventPages[$keyPage];
		console.log(`page of index ${$keyPage} is :`, $page);
		if (empty($page)) continue;
		console.log("page is not empty");
		if (empty($page['list'])) continue;
		
		// reset list for translatedPage
		translatedPage[$keyPage].list = [];


		var $messagePossition = ["top", "middle", "bottom"];
		var $currentTextParam = {};
		var $currentLongTextParam = {};
		var last101 = {};
		var last105 = {};
		for ($i=0; $i<$page['list'].length; $i++) {
			var $currentLine = $page['list'][$i];
			var $thisObj = {};
			//console.log("handling command", $currentLine);
			// process current text buffer when not 401
			if (!empty($currentText) && $page['list'][$i]['code'] != 401) {
				console.log("registering texts", $currentText);
				var $thisLine = {};
				//$thisLine['context'] = [];
				//$thisLine['parameters'] = $thisLine['parameters'] || [];
				//$thisLine['text'] = $currentText.join("\n");
				var $pictureStatus = "noPicture";
				if (!empty($currentTextParam['headerParam'][0])) $pictureStatus = "hasPicture";
				//$thisLine['context'].push($parentContext+`/${$keyPage}/list/${$currentTextParam['headerIndex']}/message/${$pictureStatus}/`+$messagePossition[$currentTextParam['headerParam'][3]]);
				//$thisLine['parameters'].push($currentTextParam);
				
				var context = common.clone($parentContext);
				context.push($keyPage, "list", $currentTextParam['headerIndex'], "message", $pictureStatus, $messagePossition[$currentTextParam['headerParam'][3]]);
				var translation = this.registerString($currentText.join("\n"), context, $currentTextParam);
				console.log("Translation: ", translation);
				if (this.writeMode) {
					var newList = this.MV_buildTextList(translation, last101);
					console.log("Generating list based on translation:", newList);
					translatedPage[$keyPage].list = translatedPage[$keyPage].list.concat(newList);
				}

				/*
				if (empty($RESULT[$thisLine['text']])) {
					$RESULT[$thisLine['text']] = $thisLine;
				} else {
					$RESULT[$thisLine['text']]['context'].push($parentContext+`/${$keyPage}/list/${$i}/message/${$pictureStatus}/`+$messagePossition[$currentTextParam['headerParam'][3]]);
					$RESULT[$thisLine['text']]['parameters'].push($currentTextParam);
				}
				*/
				// important, resets $currentText
				$currentText = [];
			}
			
			if (!empty($currentLongText) && $page['list'][$i]['code'] != 405) {
				var $thisLine = {};
				/*
				$thisLine['context'] = [];
				$thisLine['parameters'] = $thisLine['parameters'] || [];
				$thisLine['text'] = implode("\n", $currentLongText);
				$thisLine['context'].push($parentContext+`/${$keyPage}/list/`+$currentLongTextParam['headerIndex']+"/scrollingMessage");
				$thisLine['parameters'].push($currentLongTextParam);


				
				if (empty($RESULT[$thisLine['text']])) {
					$RESULT[$thisLine['text']] = $thisLine;
				} else {
					$RESULT[$thisLine['text']]['context'].push($parentContext+`/${$keyPage}/list/`+$currentLongTextParam['headerIndex']+"/scrollingMessage");
					$RESULT[$thisLine['text']]['parameters'].push($currentLongTextParam);
				}
				*/
				var context = common.clone($parentContext);
				context.push($keyPage, "list", $currentLongTextParam['headerIndex'], "scrollingMessage");
				var translation = this.registerString($currentLongText.join("\n"), context, $currentLongTextParam);
				if (this.writeMode) {
					var newList = this.MV_buildScrollTextList(translation, last105);
					console.log("Generating list based on translation:", newList);
					translatedPage[$keyPage].list = translatedPage[$keyPage].list.concat(newList);
				}
				$currentLongText = [];
			}
			
			switch($page['list'][$i]['code']) {
				// handling interpolatable texts
				case 101: //text parameters
					$currentTextParam['headerIndex'] = $i;
					$currentTextParam['headerParam'] = $page['list'][$i]['parameters'];
					$currentText = [];
					last101 = $currentLine;
					break;
				case 105: //start text scroll
					$currentLongTextParam['headerIndex'] = $i;
					$currentLongTextParam['headerParam'] = $page['list'][$i]['parameters'];
					$currentLongText = [];
					last105 = $currentLine;
					break;
				case 401: //text
					//console.log("pushing text:", $currentLine['parameters'][0]);
					$currentText.push($currentLine['parameters'][0]);
					break;
				case 405: //long text
					$currentLongText.push($currentLine['parameters'][0]);
					break;
				
				// handling non interpolatable texts
				case 122: //set variable
					//var $thisLine = {};
					//$thisLine['text'] = $currentLine['parameters'][4];
					//if (typeof $thisLine['text'] !== 'string') break;
					var thisText = $currentLine['parameters'][4];
					if (typeof thisText !== 'string') break;
					var context = common.clone($parentContext);
					context.push($keyPage, "list", $i, RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']], "/var:"+$currentLine['parameters'][0]+"-"+$currentLine['parameters'][1]);
					var translation = this.registerString(thisText, context, [], {tags: ["red"]});
					this.setEntryPointValue($currentLine['parameters'], 4, translation);
					translatedPage[$keyPage].list.push($currentLine);

					/*
					$thisLine['context'] =  [$parentContext+`/${$keyPage}/list/${$i}/`+RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]+"/var:"+$currentLine['parameters'][0]+"-"+$currentLine['parameters'][1]];
					$thisLine['parameters'] = [];
					$thisLine['tags'] = ["red"];

	
					
					if (empty($RESULT[$thisLine['text']])) {
						$RESULT[$thisLine['text']] = $thisLine;
					} else {
						$RESULT[$thisLine['text']]['context'] = [$thisLine['context'][0]];
						$RESULT[$thisLine['text']]['parameters'] = [];
					}
					*/			
					break;
				case 402: //choice
					var thisText = $currentLine['parameters'][1];
					if (typeof thisText !== 'string') break;
					var context = common.clone($parentContext);
					context.push($keyPage, "list", $i, RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]);
					var translation = this.registerString(thisText, context, [], {});
					this.setEntryPointValue($currentLine['parameters'], 1, translation);
					translatedPage[$keyPage].list.push($currentLine);

					/*
					var $thisLine = {};
					$thisLine['text'] = $currentLine['parameters'][1];
					$thisLine['context'] =  [$parentContext+`/${$keyPage}/list/${$i}/`+RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]];
					$thisLine['parameters'] = [];
					if (empty($RESULT[$thisLine['text']])) {
						$RESULT[$thisLine['text']] = $thisLine;
					} else {
						$RESULT[$thisLine['text']]['context'] = [$thisLine['context'][0]];
						$RESULT[$thisLine['text']]['parameters'] = [];
					}	
					*/				
					break;				
				case 320: //Change name
				case 324: //Change nick name
				case 325: //Change profile
					var thisText = $currentLine['parameters'][1];
					if (typeof thisText !== 'string') break;
					var context = common.clone($parentContext);
					context.push($keyPage, "list", $i, RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']], "charId:"+$currentLine['parameters'][0]);
					var translation = this.registerString(thisText, context, [], {});
					this.setEntryPointValue($currentLine['parameters'], 1, translation);
					translatedPage[$keyPage].list.push($currentLine);



					/*
					var $thisLine = {};
					$thisLine['text'] = $currentLine['parameters'][1];
					$thisLine['context'] =  [$parentContext+`/${$keyPage}/list/${$i}/`+RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]+"/charId:"+$currentLine['parameters'][0]];
					$thisLine['parameters'] = [];
					if (empty($RESULT[$thisLine['text']])) {
						$RESULT[$thisLine['text']] = $thisLine;
					} else {
						$RESULT[$thisLine['text']]['context'] = [$thisLine['context'][0]];
						$RESULT[$thisLine['text']]['parameters'] = [];
					}	
					*/				
					break;
					
				case 355: //Script Header
				case 655: //Script
				case 356: //plugin command
					var thisText = $currentLine['parameters'][0];
					if (typeof thisText !== 'string') break;
					var context = common.clone($parentContext);
					context.push($keyPage, "list", $i, RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]);
					var translation = this.registerString(thisText, context, [], {tags:["red"]});
					this.setEntryPointValue($currentLine['parameters'], 0, translation);
					translatedPage[$keyPage].list.push($currentLine);


					/*
					var $thisLine = {};
					$thisLine['text'] = $currentLine['parameters'][0];
					$thisLine['context'] =  [$parentContext+`/${$keyPage}/list/${$i}/`+RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]];
					$thisLine['parameters'] = [];
					$thisLine['tags'] = ["red"];
					if (empty($RESULT[$thisLine['text']])) {
						$RESULT[$thisLine['text']] = $thisLine;
					} else {
						$RESULT[$thisLine['text']]['context'] = [$thisLine['context'][0]];
						$RESULT[$thisLine['text']]['parameters'] = [];
					}	
					*/				
					break;
				
				default:
					translatedPage[$keyPage].list.push($currentLine);
			}
		}
	}

	this.parsed = $RESULT;
	console.log(">>>Translated page:", translatedPage);
	return translatedPage;
}

/*

RMMVData.prototype.fetchEventPages = function($eventPages, $parentContext = '', $RESULT = {}) {
	console.log("handling Event pages", arguments);
	if (!Array.isArray($eventPages)) return false;
	var $currentText = [];
	var $currentLongText = [];
	for(var $keyPage in $eventPages) {
		var $page = $eventPages[$keyPage];
		console.log(`page of index ${$keyPage} is :`, $page);
		if (empty($page)) continue;
		console.log("page is not empty");
		if (empty($page['list'])) continue;
		
		var $messagePossition = ["top", "middle", "bottom"];
		var $currentTextParam = {};
		var $currentLongTextParam = {};
		for ($i=0; $i<$page['list'].length; $i++) {
			var $currentLine = $page['list'][$i];
			var $thisObj = {};
			
			// process current text buffer when not 401
			if (!empty($currentText) && $page['list'][$i]['code'] != 401) {
				var $thisLine = {};
				$thisLine['context'] = [];
				$thisLine['parameters'] = $thisLine['parameters'] || [];
				$thisLine['text'] = $currentText.join("\n");
				$pictureStatus = "noPicture";
				if (!empty($currentTextParam['headerParam'][0])) $pictureStatus = "hasPicture";
				$thisLine['context'].push($parentContext+`/${$keyPage}/list/${$currentTextParam['headerIndex']}/message/${$pictureStatus}/`+$messagePossition[$currentTextParam['headerParam'][3]]);
				$thisLine['parameters'].push($currentTextParam);
				
				if (empty($RESULT[$thisLine['text']])) {
					$RESULT[$thisLine['text']] = $thisLine;
				} else {
					$RESULT[$thisLine['text']]['context'].push($parentContext+`/${$keyPage}/list/${$i}/message/${$pictureStatus}/`+$messagePossition[$currentTextParam['headerParam'][3]]);
					$RESULT[$thisLine['text']]['parameters'].push($currentTextParam);
				}
				$currentText = [];
			}
			
			if (!empty($currentLongText) && $page['list'][$i]['code'] != 405) {
				var $thisLine = {};
				$thisLine['context'] = [];
				$thisLine['parameters'] = $thisLine['parameters'] || [];
				$thisLine['text'] = implode("\n", $currentLongText);
				$thisLine['context'].push($parentContext+`/${$keyPage}/list/`+$currentLongTextParam['headerIndex']+"/scrollingMessage");
				$thisLine['parameters'].push($currentLongTextParam);
				if (empty($RESULT[$thisLine['text']])) {
					$RESULT[$thisLine['text']] = $thisLine;
				} else {
					$RESULT[$thisLine['text']]['context'].push($parentContext+`/${$keyPage}/list/`+$currentLongTextParam['headerIndex']+"/scrollingMessage");
					$RESULT[$thisLine['text']]['parameters'].push($currentLongTextParam);
				}
				$currentLongText = [];
			}
			
			switch($page['list'][$i]['code']) {
				case 101: //text parameters
					$currentTextParam['headerIndex'] = $i;
					$currentTextParam['headerParam'] = $page['list'][$i]['parameters'];
					$currentText = [];
					break;
				case 105: //start text scroll
					$currentLongTextParam['headerIndex'] = $i;
					$currentLongTextParam['headerParam'] = $page['list'][$i]['parameters'];
					$currentLongText = [];
					break;
				case 401: //text
					$currentText.push($currentLine['parameters'][0]);
					break;
				case 405: //long text
					$currentLongText.push($currentLine['parameters'][0]);
					break;
				
				case 122: //set variable
					var $thisLine = {};
					$thisLine['text'] = $currentLine['parameters'][4];
					if (typeof $thisLine['text'] !== 'string') break;
					
					$thisLine['context'] =  [$parentContext+`/${$keyPage}/list/${$i}/`+RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]+"/var:"+$currentLine['parameters'][0]+"-"+$currentLine['parameters'][1]];
					$thisLine['parameters'] = [];
					$thisLine['tags'] = ["red"];
					
					if (empty($RESULT[$thisLine['text']])) {
						$RESULT[$thisLine['text']] = $thisLine;
					} else {
						$RESULT[$thisLine['text']]['context'] = [$thisLine['context'][0]];
						$RESULT[$thisLine['text']]['parameters'] = [];
					}					
					break;
				case 402: //choice
					var $thisLine = {};
					$thisLine['text'] = $currentLine['parameters'][1];
					$thisLine['context'] =  [$parentContext+`/${$keyPage}/list/${$i}/`+RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]];
					$thisLine['parameters'] = [];
					if (empty($RESULT[$thisLine['text']])) {
						$RESULT[$thisLine['text']] = $thisLine;
					} else {
						$RESULT[$thisLine['text']]['context'] = [$thisLine['context'][0]];
						$RESULT[$thisLine['text']]['parameters'] = [];
					}					
					break;				
				case 320: //Change name
				case 324: //Change nick name
				case 325: //Change profile
					var $thisLine = {};
					$thisLine['text'] = $currentLine['parameters'][1];
					$thisLine['context'] =  [$parentContext+`/${$keyPage}/list/${$i}/`+RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]+"/charId:"+$currentLine['parameters'][0]];
					$thisLine['parameters'] = [];
					if (empty($RESULT[$thisLine['text']])) {
						$RESULT[$thisLine['text']] = $thisLine;
					} else {
						$RESULT[$thisLine['text']]['context'] = [$thisLine['context'][0]];
						$RESULT[$thisLine['text']]['parameters'] = [];
					}					
					break;
					
				case 355: //Script Header
				case 655: //Script
				case 356: //plugin command
					var $thisLine = {};
					$thisLine['text'] = $currentLine['parameters'][0];
					$thisLine['context'] =  [$parentContext+`/${$keyPage}/list/${$i}/`+RMMVData['RPGM_EVENT_CODE'][$page['list'][$i]['code']]];
					$thisLine['parameters'] = [];
					$thisLine['tags'] = ["red"];
					if (empty($RESULT[$thisLine['text']])) {
						$RESULT[$thisLine['text']] = $thisLine;
					} else {
						$RESULT[$thisLine['text']]['context'] = [$thisLine['context'][0]];
						$RESULT[$thisLine['text']]['parameters'] = [];
					}					
					break;
			}
		}
	}

	this.parsed = $RESULT;
	return this;
}
*/


RMMVData.prototype.fetchSystem = function($system, $parentContext, $currentData = []) {
	
	if (!empty($system['gameTitle'])) {
		//var $newData = {};
		//$newData['text'] = $system['gameTitle'];
		//$newData['context'] = [`${$parentContext}/gameTitle`];
		//$currentData = this.appendResultData($currentData, $newData);
		if (this.debugLevel>1) console.log("Fetch gameTitle");
		var context = $parentContext.concat(["gameTitle"]);
		this.registerStringObject($system, 'gameTitle', context, [], {currentAddress : ["gameTitle"]})
	}

	var $type = ['armorTypes', 'elements', 'equipTypes', 'skillTypes', 'weaponTypes'];	
	for (var $i in $type) {
		var $key = $type[$i];
		if (empty($system[$key])) continue;
		for (var $thisKey in $system[$key] ) {
			var $thisText = $system[$key][$thisKey];
			if (empty($thisText)) continue;
			//$newData = {};
			//$newData['text'] = $thisText;
			//$newData['context'] = [`${$parentContext}/${$key}/${$thisKey}`];
			
			//$currentData = this.appendResultData($currentData, $newData);
			if (this.debugLevel>2) console.log(">>>Fetch type definition: "+$key);
			if (this.debugLevel>2) console.log($system[$key], $thisKey, ">>", $system[$key][$thisKey]);

			var context = $parentContext.concat([$key, $thisKey]);
			//this.registerString($thisText, context, [], {currentAddress : [$key, $thisKey]})
			this.registerStringObject($system[$key], $thisKey, context, [], {currentAddress : [$key, $thisKey]})
	
		}
	}
	
	for (var $key in $system['terms']) {
		var $terms = $system['terms'][$key];
		for (var $thisKey in $terms) {
			var $thisText = $terms[$thisKey];
			if (Boolean($thisText) == false) continue;
			//$newData = {};
			//$newData['text'] = $thisText;
			//$newData['context'] = [`${$parentContext}/terms/${$key}/${$thisKey}`];
			
			//$currentData = this.appendResultData($currentData, $newData);
			if (this.debugLevel>2) console.log(">>>Fetch terms");
			if (this.debugLevel>2) console.log("$terms:", $terms);
			if (this.debugLevel>2) console.log("$thisKey:", $thisKey);
			if (this.debugLevel>2) console.log("$terms[$thisKey]:", $terms[$thisKey]);
			var context = $parentContext.concat(["terms", $key, $thisKey]);
			//this.registerString($thisText, context, [], {currentAddress : ["terms", $key, $thisKey]})
			this.registerStringObject($terms, $thisKey, context, [], {currentAddress : ["terms", $key, $thisKey]})

		}
	}
	
	//this.parsed = $currentData;
	if (this.writeMode) this.writableObj = $system;
	return this;
}

RMMVData.mergeDeep = function(target, ...sources) {
	if (!sources.length) return target;
	const source = sources.shift();
  
	if (typeof target == "object" && typeof source == "object") {
	  for (const key in source) {
		if (typeof source[key] == "object") {
		  if (!target[key]) Object.assign(target, { [key]: {} });
		  this.mergeDeep(target[key], source[key]);
		} else {
		  Object.assign(target, { [key]: source[key] });
		}
	  }
	}
  
	return this.mergeDeep(target, ...sources);
}

RMMVData.prototype.appendResultData = function($currentData, $newData) {
	if (!Array.isArray($currentData)) return false;
	if (empty($newData['text'])) return $currentData;

	if (!empty($currentData[$newData['text']])) {
		$currentData[$newData['text']] = RMMVData.mergeDeep($currentData[$newData['text']], $newData);
		$currentData[$newData['text']]['text'] = $newData['text'];
	} else {
		$currentData[$newData['text']] = $newData;
	}
	return $currentData;
}



RMMVData.prototype.fetchFromOtherJson = function(obj, context, translationPair) {
	obj = obj || this.obj;
	obj = common.clone(obj);
	translationPair = translationPair || this.translationPair;

	if (!Boolean(context)) context = [];
	if (Array.isArray(context) == false) context = [context];

	var fetchChild = (childObj, localContext) => {
		// create new clone of localContext
		if (Array.isArray(localContext) == false) localContext = [localContext];

		for (var i in childObj) {
			var newContext = common.clone(localContext);
			newContext.push(i);
			if (Boolean(childObj[i]) == false) continue
			if (common.isNumeric(childObj[i])) continue;
			if (typeof childObj[i] == 'object') {
				fetchChild(childObj[i], newContext);
			} else if (typeof childObj[i] == 'string') {
				//var contextString = newContext.join("/");
				//if (contextString.includes("parameters") == false) continue;
				//if (RMMV.isCommonOperatorString(childObj[i])) continue;
				if (!common.isTranslatableText(childObj[i])) continue;				
				
				//childObj[i] = this.registerString(childObj[i], newContext);
				childObj[i] = this.registerStringObject(childObj, i, newContext);
			}
			
		}
	}

	fetchChild(obj, context);
	this.writableObj = obj;
	return this;
}
/*
RMMVData.prototype.fetchFromOtherJson = function($currentData, $parent) {
	if (!Array.isArray($currentData)) return $currentData;

	var $RESULT = {};
	for (var $key in $currentData) {
		$val = $currentData[$key];
		if (Array.isArray($val)) {
			var $CHILD = this.fetchFromOtherJson($val, $parent+"/"+$key);
			for (var $childKey in $CHILD) {
				var $childVal = $CHILD[$childKey];
				if (empty($RESULT[$childKey])) {
					$RESULT[$childKey] = $childVal;
				} else {
					$RESULT[$childKey]['context'] = Object.assign($RESULT[$childKey]['context'], $childVal['context']);
				}
			}
			
		} else {
			if (typeof $val !== "string") continue;
			if (typeof $val == "number") continue;
			var $content = {};
			$content['text'] = $val;
			$content['context'] = [$parent+"/"+$key];
			if (empty($RESULT[$val])) {
				$RESULT[$val] = $content;
			} else {
				$RESULT[$val]['context'].push($content['context'][0]);
			}
			
		}
		
	}
	
	this.parsed = $RESULT;
	return this;
}
*/


RMMVData.prototype.setEntryPoint = function(obj, key) {
	this.currentEntryPoint.obj = obj;
	this.currentEntryPoint.key = key;
}

RMMVData.prototype.setEntryPointValue = function(obj, key, value) {
	this.currentEntryPoint.obj = obj;
	this.currentEntryPoint.key = key;
	try {
		obj[key] = value;
	} catch (e) {
		console.warn(e);
	}
}

RMMVData.selectTranslationData = function(translationDatas, path) {
	// must match trans.project.files[thefile].path
	var newPath = path;
	newPath = newPath.replace(/\\/g, "/");
	translationDatas.translationData = translationDatas.translationData || {};
	return translationDatas.translationData[newPath];
}

RMMVData.getRelativePath = function(longPath, shortPath) {
	longPath = longPath.replaceAll("\\", "/");
	var result = longPath.substr(shortPath.length);
	if (result[0] == "/") result = result.substr(1);
	return result;
}

RMMVData.extract = async function($MV_PATH, options) {
	options = options || {};
	options.translationDatas = options.translationDatas || {};

	if (!common.isFileAsync(nwPath.join($MV_PATH,'data/System.json'))) {
		$MV_PATH = nwPath.join($MV_PATH,'www');
	}
	if (!common.isFileAsync(nwPath.join($MV_PATH,'/data/System.json'))) {
		return "System.json not found";
	}


	var files = await common.readDir(nwPath.join($MV_PATH, "data"));


	var $RESULT = {};
	for (var $key in files) {
		var $path = files[$key];
		var $fileInfo = {};
		$fileInfo['extension'] = nwPath.extname($path).toLowerCase().substring(1);
		console.log("extension:", $path, $fileInfo['extension']);
		if ($fileInfo['extension'] !== 'json')	continue;
		$fileInfo['relPath'] = $path.substring(nwPath.join($MV_PATH,'\data').length+1);
		$fileInfo['dataType'] = RMMVData.determineType($path);
		$fileInfo['filename'] = nwPath.basename($path, nwPath.extname($path));
		$fileInfo['basename'] = nwPath.basename($path);
		console.log("File info:", $fileInfo);
		var $currentData = JSON.parse(await common.fileGetContents($path));

		var $THISFETCH;

		if (empty($currentData)) continue;
		var rmmvData = new RMMVData($currentData, {fileInfo: $fileInfo});
		var relativePath = RMMVData.getRelativePath($path, $MV_PATH);
		console.warn("Relative path is : ", relativePath);

		//rmmvData.data = $currentData;
		if (options.writeMode) {
			rmmvData.writeMode = true;
			rmmvData.writableObj = common.clone($currentData);
			if (!empty(options.translationDatas)) {
				var translationData = RMMVData.selectTranslationData(options.translationDatas, relativePath);
				console.log("Translation Data:", translationData);
				translationData = translationData || {};
				rmmvData.translationPair = translationData.translationPair || {};
				rmmvData.translationInfo = translationData.info || {};
			}
		}

		switch ($fileInfo['dataType']) {
			case "items":
			case "armors":
			case "weapons":
				$THISFETCH = rmmvData.fetchCommonData($currentData, ["name", "description", "note"], [$fileInfo['filename']]);
				$RESULT[$path] = $THISFETCH;
				break;
			case "skills":
				$THISFETCH = rmmvData.fetchCommonData($currentData, ["name", "description", "message1", "message2", "note"], [$fileInfo['filename']]);
				$RESULT[$path] = $THISFETCH;
				break;
			case "states":
				$THISFETCH = rmmvData.fetchCommonData($currentData, ["name", "message1", "message2", "message3", "message4", "note"], [$fileInfo['filename']]);
				$RESULT[$path] = $THISFETCH;
				break;
			case "classes":
			case "enemies":
			case "tilesets":
				$THISFETCH = rmmvData.fetchCommonData($currentData,["name", "note"], [$fileInfo['filename']]);
				$RESULT[$path] = $THISFETCH;
				break;
			case "animations":
			case "mapinfos":
				$THISFETCH = rmmvData.fetchCommonData($currentData, ["name"], [$fileInfo['filename']]);
				$RESULT[$path] = $THISFETCH;
				break;
			case "actors":
				$THISFETCH = rmmvData.fetchCommonData($currentData, ["name", "nickname", "note", "profile"], [$fileInfo['filename']]);
				$RESULT[$path] = $THISFETCH;
				break;
			case "map":
				$THISFETCH = {};
				$newData = {};
				// fetch map name
				//$newData['text'] = $currentData['displayName'];
				//$newData['context'] = [$fileInfo['filename']+"/displayName"];
				//$THISFETCH = rmmvData.appendResultData($THISFETCH, $newData);
				//rmmvData.registerString($currentData['displayName'], [$fileInfo.filename, "displayName"], [], {currentAddress:["displayName"]})
				rmmvData.registerStringObject($currentData, 'displayName', [$fileInfo.filename, "displayName"], [], {currentAddress:["displayName"]})


				// fetch map note
				//$newData['text'] = $currentData['note'];
				//$newData['context'] = [$fileInfo['filename']+"/note"];
				//$THISFETCH = rmmvData.appendResultData($THISFETCH, $newData);
				//rmmvData.registerString($currentData['note'], [$fileInfo.filename, "note"], [], {currentAddress:["note"]})
				rmmvData.registerStringObject($currentData, 'note', [$fileInfo.filename, "note"], [], {currentAddress:["note"]})

				
				if ($currentData['events'].length<2) {
					$RESULT[$path] = rmmvData;
					break;
				}

				
				for (var $eIndex=1; $eIndex<$currentData['events'].length; $eIndex++) {
					if (empty($currentData['events'][$eIndex])) continue;
					// fetch event name
					//rmmvData.registerString($currentData['events'][$eIndex]['name'], [$fileInfo.filename, "events", $eIndex, "name"], [], {currentAddress : ["events", $eIndex, "name"]})
					rmmvData.registerStringObject($currentData['events'][$eIndex], 'name', [$fileInfo.filename, "events", $eIndex, "name"], [], {currentAddress : ["events", $eIndex, "name"]})
					// fetch event note
					//rmmvData.registerString($currentData['events'][$eIndex]['note'], [$fileInfo.filename, "events", $eIndex, "note"], [], {currentAddress : ["events", $eIndex, "note"]})
					rmmvData.registerStringObject($currentData['events'][$eIndex], 'note', [$fileInfo.filename, "events", $eIndex, "note"], [], {currentAddress : ["events", $eIndex, "note"]})
					// fetch event pages content
					var eventPage = rmmvData.fetchEventPages($currentData['events'][$eIndex]['pages'], [$fileInfo.filename, "events", $eIndex, "pages"], $THISFETCH, {currentAddress:["events", $eIndex, "pages"]});	
					if (options.writeMode) rmmvData.writableObj['events'][$eIndex]['pages'] = eventPage;
				}

				$RESULT[$path] = rmmvData;
				break;
			case "troops":
				if ($currentData.length<2) break;
				if (empty($currentData)) continue;

				$THISFETCH = {};
				$THISFETCH = rmmvData.fetchCommonData($currentData, ["name"], [$fileInfo['filename']]);
			
				for (var $eIndex=1; $eIndex < $currentData.length; $eIndex++) {
					if (empty($currentData[$eIndex]['pages'])) continue;
					// fetch event pages content
					var eventPage = rmmvData.fetchEventPages($currentData[$eIndex]['pages'], [$fileInfo.filename, $eIndex, "pages"], $THISFETCH, {currentAddress:[$eIndex, "pages"]});	
					if (options.writeMode) rmmvData.writableObj[$eIndex]['pages'] = eventPage;

				}
				
				$RESULT[$path] = rmmvData;
				break;
			case "commonevents":
				if ($currentData.length<2) break;
				if (empty($currentData)) continue;
				//$THISFETCH = {};
				//$newData = {};
				// fetch name manually
				for ($eIndex=1; $eIndex<$currentData.length; $eIndex++) {
					if (empty($currentData[$eIndex])) continue;
					if (empty($currentData[$eIndex]['name'])) continue;
					/*
					$newData['text'] = $currentData[$eIndex]['name'];
					$newData['context'] = [$fileInfo['filename']+"/"+$eIndex+"/name"];
					$THISFETCH = rmmvData.appendResultData($THISFETCH, $newData);
					*/
					//rmmvData.registerString($currentData[$eIndex]['name'], [$fileInfo.filename, $eIndex, "name"], [], {currentAddress:[$eIndex, "name"]})
					rmmvData.registerStringObject($currentData[$eIndex], 'name', [$fileInfo.filename, $eIndex, "name"], [], {currentAddress:[$eIndex, "name"]})

				}

				// the entire common events are a single event pages
				var eventPage = rmmvData.fetchEventPages($currentData, [$fileInfo.filename], $THISFETCH, {currentAddress:[]});	
				if (options.writeMode) rmmvData.writableObj = eventPage;

				$RESULT[$path] = rmmvData;
				break;
			case "system":
				$RESULT[$path] = rmmvData.fetchSystem($currentData, [$fileInfo.filename]);
			
				break;
			default:
				$RESULT[$path] = rmmvData.fetchFromOtherJson($currentData, [$fileInfo.filename]);

				break;
		}

	}	
	
	//return  this.normalizeMVData($RESULT);	
	return $RESULT;
}

window.RMMVData = RMMVData;



class JSONTranslate extends require("www/js/ParserBase.js").ParserBase {
	constructor(obj, options, callback) {
		super(obj, options, callback)
		this.obj = obj || {};
	}
}

JSONTranslate.prototype.translateString = function(text, context) {
	if (typeof text !== 'string') return text;
	if (text.trim() == '') return text;
	console.log("attempt to translate ", text, this.translationPair);

	// compare with exact context match
	var prefix = context.join("/")
	prefix = prefix+"\n";
	if (Boolean(this.translationPair[prefix+text])) return this.translationPair[prefix+text];


	// compare with group
	var sliceLevel = this.translationInfo.groupLevel || 0;
	if (sliceLevel > 0) {
		prefix = context.slice(0, sliceLevel).join("/")
		prefix = prefix+"\n";
		//if (window.monitoringMode) console.log("%cTranslate by group",  'background: #00F; color: #fff', prefix);
		if (Boolean(this.translationPair[prefix+text])) return this.translationPair[prefix+text];
	}

	//console.log("found in translation pair?", this.translationPair[text]);
	
	if (typeof this.translationPair[text] == 'undefined') return text;
	
	return this.translationPair[text];
}

/**
 * Generate translation table from any object
 * This is useful for handling misc JSON files
 * @param  {} obj
 * @param  {} context
 */
 JSONTranslate.prototype.getTranslationTableFromObj = function(obj, context) {
	obj = obj || this.obj;
	if (!Boolean(context)) context = [];
	if (Array.isArray(context) == false) context = [context];
	var index = {};
	var result = {
		data:[],
		context:[]
	}

	var fetchChild = (childObj, localContext) => {
		// create new clone of localContext
		if (Array.isArray(localContext) == false) localContext = [localContext];

		for (var i in childObj) {
			var newContext = common.clone(localContext);
			newContext.push(i);
			if (Boolean(childObj[i]) == false) continue
			if (common.isNumeric(childObj[i])) continue;
			if (typeof childObj[i] == 'object') {
				fetchChild(childObj[i], newContext);
			} else if (typeof childObj[i] == 'string') {
				var contextString = newContext.join("/");
				if (contextString.includes("parameters") == false) continue;
				if (RMMV.isCommonOperatorString(childObj[i])) continue;
				if (!common.isTranslatableText(childObj[i])) continue;				
				if (index[childObj[i]]) {
					var thisIndex = index[childObj[i]];
					result.context[thisIndex] = result.context[thisIndex] || [];
					result.context[thisIndex].push(contextString);
					continue;
				}

				var thisIndex = result.data.push([childObj[i]]) -1;
				result.context[thisIndex] = result.context[thisIndex] || [];
				result.context[thisIndex].push(contextString);
				index[childObj[i]] = thisIndex;
			}
			
		}
	}

	fetchChild(obj, context);
	result.indexIds = index;
	return result;
}


JSONTranslate.prototype.translateObj = function(obj, context, translationPair) {
	obj = obj || this.obj;
	obj = common.clone(obj);
	translationPair = translationPair || this.translationPair;

	if (!Boolean(context)) context = [];
	if (Array.isArray(context) == false) context = [context];

	var fetchChild = (childObj, localContext) => {
		// create new clone of localContext
		if (Array.isArray(localContext) == false) localContext = [localContext];

		for (var i in childObj) {
			var newContext = common.clone(localContext);
			newContext.push(i);
			if (Boolean(childObj[i]) == false) continue
			if (common.isNumeric(childObj[i])) continue;
			if (typeof childObj[i] == 'object') {
				fetchChild(childObj[i], newContext);
			} else if (typeof childObj[i] == 'string') {
				var contextString = newContext.join("/");
				if (contextString.includes("parameters") == false) continue;
				if (RMMV.isCommonOperatorString(childObj[i])) continue;
				if (!common.isTranslatableText(childObj[i])) continue;				
				
				childObj[i] = this.translateString(childObj[i], newContext);
				

			}
			
		}
	}

	fetchChild(obj, context);
	this.translated = obj;
	return obj;
}



/**
 * @param  {} rootDir
 * rootDir is the place where index.html resides
 * @param  {} options
 */
var RMMV = function(rootDir, options) {
	this.rootDir 		= rootDir;
	this.options		= options || {};
	this.options.pluginPath	= this.options.pluginPath || "js/plugins/";
	this.options.translationDatas = this.options.translationDatas || {}
}



// utils
RMMV.getExe = async function(dir) {
	var list = await common.getAllExt(dir, "exe");
	var blacklist = ["notification_helper"]
	for (var i in list) {
		if (blacklist.includes(list[i])) continue;
		return list[i];
	}
	return false;
}

RMMV.isCommonOperatorString = function(string) {
	if (typeof string !== 'string') return false;
	var common = ["on", "off", "true", "false"];
	if (common.includes(string.toLowerCase())) return true;
	return false;
}
/**
 * load data relative to rootDir
 * data will be stored to files
 * @param  {} files
 */
RMMV.prototype.load = async function(files) {
	this.files = this.files || {};
	if (Array.isArray(files) == false) files = [files];

	var output = {};
	for (var i in files) {
		var fullPath = nwPath.join(this.rootDir, files[i]);
		if (!await common.isFileAsync(fullPath)) continue;
		try {
			var raw = await common.fileGetContents(fullPath);
			this.files[files] = JSON.parse(raw);
			output[files] = this.files[files];
		} catch (e) {
			console.warn(e)
		}

	}
	return output;
}

/**
 * Parse JSON content of plugins.js
 * plugins.js itself is a js file not a json file
 * so we need to get anything between the first "[" to the last "]"
 * @param  {String} pluginContent - Content of plugins.js
 */
RMMV.getParsedPluginContent = function(pluginContent) {
	var start = pluginContent.indexOf("[");
	var end = pluginContent.lastIndexOf("]");
	var trimmed = pluginContent.substring(start, end+1);		

	try {
		this.plugins = JSON.parse(trimmed);
	} catch(e) {
		console.warn("error when parsing plugin script");
	}
	return this.plugins;
}

RMMV.prototype.parsePluginList = async function(options) {
	console.log("opening", nwPath.join(this.rootDir, "js/plugins.js"));
	try {
		var pluginContent = await common.fileGetContents(nwPath.join(this.rootDir, "js/plugins.js"));

	} catch (e) {
		console.warn(e);
		return;
	}
	var start = pluginContent.indexOf("[");
	var end = pluginContent.lastIndexOf("]");
	var trimmed = pluginContent.substring(start, end+1);		

	try {
		this.plugins = JSON.parse(trimmed);
	} catch(e) {
		console.warn("error when parsing plugin script");
	}
	return this.plugins;
}
/**
 * Dump untranslated plugins to directory
 * @param  {} dir
 */
RMMV.prototype.dumpPluginsToDir = async function(dir) {
	if (!Boolean(dir)) throw "first argument (dir) is blank"
	if (!Boolean(this.plugins)) await this.parsePlugins();
	await common.mkDir(dir);
	for (var file in this.pluginData) {
		var targetPath = nwPath.join(dir, file);
		await bCopy(this.pluginData[file].file, targetPath);
	}
	console.log("Copying pluginlist");
	var pluginList = nwPath.join(this.rootDir, "js/plugins.js");
	await bCopy(pluginList, nwPath.join(dir, "js/plugins.js"));
}

RMMV.prototype.writePluginListTo = async function(targetPath) {
	console.log("writePluginListTo", targetPath);
	// toDo translating pluginList
	this.options.translationDatas 		= this.options.translationDatas || {};
	this.pluginListObj.translationData 	= this.options.translationDatas["js/plugins.js"] || this.options.translationDatas["/js/plugins.js"] || {};
	this.pluginListObj.translationPair 	= this.pluginListObj.translationData.translationPair || {};
	var translated = this.pluginListObj.translateObj();
	var translatedStr = `// Generated by Translator++.\n// Do not edit this file directly.\nvar $plugins =\n`+JSON.stringify(translated, undefined, 2)+";";
	console.log("Writing", targetPath);
	await common.mkDir(nwPath.dirname(targetPath));
	await common.writeFile(targetPath, translatedStr);
	console.log("Written:", targetPath);
}

RMMV.prototype.exportPluginsToFolder = async function(dir) {
	if (!Boolean(dir)) throw "first argument (dir) is blank"
	if (!Boolean(this.plugins)) await this.parsePlugins();
	await common.mkDir(dir);	
	for (var file in this.pluginData) {
		var targetPath = nwPath.join(dir, file);
		this.pluginData[file].writeTo(targetPath);
	}
	console.log("exporting plugin list ...");
	try {
		await this.writePluginListTo(nwPath.join(dir, "js/plugins.js"))
	} catch (e) {
		console.warn("failed to write plugin list", e);
	}
	console.log("exporting plugin list done");
}

RMMV.prototype.selectTranslationData = function(path) {
	// must match trans.project.files[thefile].path
	var newPath = "/"+path;
	newPath = newPath.replace(/\\/g, "/");
	console.log("===================");
	console.log("selecting translation from ", path);
	console.log(this.options.translationDatas[newPath]);
	console.log("===================");
	return this.options.translationDatas[newPath];
	
}

RMMV.prototype.parsePlugins = async function(options) {
	var options = options || this.options || {};
	options.baseDir = options.baseDir || this.rootDir;

	// parse plugins
	if (!Boolean(this.plugins)) await this.parsePluginList(options);
	this.pluginData = {};

	console.log("Plugins : ", this.plugins);
	for (var i in this.plugins) {
		var thisPath = nwPath.join(this.rootDir, this.options.pluginPath, this.plugins[i].name+".js");
		var pluginPath = nwPath.join(this.options.pluginPath, this.plugins[i].name+".js");
		console.log("parsing", thisPath);
		if (await common.isFileAsync(thisPath) == false) continue;
		
		this.pluginData[pluginPath] = new ESFile(thisPath, options);
		this.pluginData[pluginPath].setTranslationData(this.selectTranslationData(pluginPath));
		await this.pluginData[pluginPath].toTrans();
	}
	await this.parsePluginListToTrans(options);
	return this;
}

RMMV.prototype.parsePluginListToTrans = async function(options) {
	var options = options || this.options || {};
	var thisRelPath = "/js/plugins.js";

	if (!Boolean(this.plugins)) await this.parsePluginList(options);
	console.log(">>parsePluginListToTrans -> options:", options);
	this.pluginListObj = new JSONTranslate(this.plugins);
	this.pluginListTrans = await this.pluginListObj.getTranslationTableFromObj();
	this.pluginListTrans.basename 	= nwPath.basename(thisRelPath);
	this.pluginListTrans.filename 	= nwPath.basename(thisRelPath);
	this.pluginListTrans.extension 	= nwPath.extname(thisRelPath);
	this.pluginListTrans.dirname 	= nwPath.dirname(thisRelPath);
	this.pluginListTrans.path		= thisRelPath;
	this.pluginListTrans.tags		= [];
	this.pluginListTrans.lineBreak  = "\n";
}

RMMV.prototype.pluginsToTrans = async function(transData) {
	transData = transData || trans;
	transData.project = transData.project || {};
	transData.project.files = transData.project.files || {};
	if (Boolean(this.pluginData) == false) await this.parsePlugins();
	for (var path in this.pluginData) {
		var nPath = path.replace(/\\/g, "/");
		transData.project.files[nPath] = this.pluginData[path].trans;
	}

	transData.project.files["js/plugins.js"] = this.pluginListTrans;
	return transData;
}

window.RMMV = RMMV;




var RMMVDecrypter = function(rootDir, options) {
	this.rootDir 		= rootDir;
	this.options 		= options;
}

RMMVDecrypter.prototype.loadData = async function(file) {
	this.files = this.files || {};

	var fullPath = nwPath.join(this.rootDir, file);
	if (!await common.isFileAsync(fullPath)) return;
	try {
		var raw = await common.fileGetContents(fullPath);
		return JSON.parse(raw);
	} catch(e) {
		console.warn(e);
	}

}

RMMVDecrypter.prototype.loadSystem = async function() {
	try {
		this.system = await this.loadData("data/System.json");
		RMMVDecrypter.Decrypter.rawEncriptionKey = this.system.encryptionKey;
	} catch (e) {
		alert(t("Error loading system.json")+e.toString());
	}
}

RMMVDecrypter.prototype.getRelativePath = function(path) {
	return path.substring(this.rootDir.length);
}

RMMVDecrypter.prototype.decryptAll = async function(targetDir) {
	targetDir = targetDir || this.rootDir;
	var possibleExt = [
		".rpgmvo", ".rpgmvm", ".rpgmvp", //mv
		".png_", ".ogg_", ".m4a_" //mz
	];
	if (!this.isInitialized) await this.init();

	var maxItem = 0;
	for (var i in this.dirContent) {
		if (!possibleExt.includes(nwPath.extname(this.dirContent[i]).toLowerCase())) continue;
		maxItem++
	}
	console.log("maxItem", maxItem);
	await ui.log(`${maxItem} items found!`);

	var x = 0;
	for (var i in this.dirContent) {
		if (!possibleExt.includes(nwPath.extname(this.dirContent[i]).toLowerCase())) continue;
		var newPath = RMMVDecrypter.Decrypter.extToDecryptExt(nwPath.join(targetDir, this.getRelativePath(this.dirContent[i])));
		console.log("Decrypting", this.dirContent[i], "into", newPath);
		try {
			await common.mkDir(nwPath.dirname(newPath));
		} catch (e) {}

		await ui.loadingProgress(Math.round((x/maxItem)*100));
		await ui.log(`Decrypting: ${this.dirContent[i]}`);
		await RMMVDecrypter.Decrypter.decrypt(this.dirContent[i], newPath);
		x++;
	}
	console.log("all process done");
	await ui.log(`All done!`);

}

RMMVDecrypter.prototype.init = async function() {
	await this.loadSystem();
	this.dirContent = await common.readDir(this.rootDir);
	this.isInitialized = true;
}


function Decrypter() {
    throw new Error('This is a static class');
}

Decrypter.rawEncriptionKey = ""; // get from System.encryptionKey
Decrypter.hasEncryptedImages = false;
Decrypter.hasEncryptedAudio = false;
Decrypter._requestImgFile = [];
Decrypter._headerlength = 16;
Decrypter._xhrOk = 400;
Decrypter._encryptionKey = "";
Decrypter._ignoreList = [
    "img/system/Window.png"
];
Decrypter.SIGNATURE = "5250474d56000000";
Decrypter.VER = "000301";
Decrypter.REMAIN = "0000000000";

Decrypter.checkImgIgnore = function(url){
    for(var cnt = 0; cnt < this._ignoreList.length; cnt++) {
        if(url === this._ignoreList[cnt]) return true;
    }
    return false;
};

Decrypter.decrypt = async function(path, targetPath) {
	return new Promise((resolve, reject) => {
		console.log(path);
		fs.readFile(path, async (err, data) => {
			if (err) {
				reject(err);
				return;
			}
			console.log("data", data);
			var arrayBuffer = Decrypter.decryptArrayBuffer(data);
			console.log("Writing : ", targetPath);
			if (targetPath) await common.writeFile(targetPath, this.toBuffer(arrayBuffer));
			console.log("done writing");
			resolve(arrayBuffer);;
		});
	})

};

Decrypter.cutArrayHeader = function(arrayBuffer, length) {
    return arrayBuffer.slice(length);
};

Decrypter.decryptArrayBuffer = function(arrayBuffer) {
    if (!arrayBuffer) return null;
	if (arrayBuffer instanceof Buffer) {
		arrayBuffer = arrayBuffer.buffer.slice(arrayBuffer.byteOffset, arrayBuffer.byteOffset + arrayBuffer.byteLength);
	}
    var header = new Uint8Array(arrayBuffer, 0, this._headerlength);

    var i;
    var ref = this.SIGNATURE + this.VER + this.REMAIN;
    var refBytes = new Uint8Array(16);
    for (i = 0; i < this._headerlength; i++) {
        refBytes[i] = parseInt("0x" + ref.substr(i * 2, 2), 16);
    }
    for (i = 0; i < this._headerlength; i++) {
        if (header[i] !== refBytes[i]) {
            throw new Error("Header is wrong");
        }
    }

    arrayBuffer = this.cutArrayHeader(arrayBuffer, Decrypter._headerlength);
    var view = new DataView(arrayBuffer);
    this.readEncryptionkey();
    if (arrayBuffer) {
        var byteArray = new Uint8Array(arrayBuffer);
        for (i = 0; i < this._headerlength; i++) {
            byteArray[i] = byteArray[i] ^ parseInt(Decrypter._encryptionKey[i], 16);
            view.setUint8(i, byteArray[i]);
        }
    }

    return arrayBuffer;
};

Decrypter.createBlobUrl = function(arrayBuffer){
    var blob = new Blob([arrayBuffer]);
    return window.URL.createObjectURL(blob);
};

Decrypter.toBuffer = function(arrayBuffer) {
	return Buffer.from(arrayBuffer)
}

Decrypter.extToEncryptExt = function(url) {
    var ext = url.split('.').pop();
    var encryptedExt = ext;

    if(ext === "ogg") encryptedExt = ".rpgmvo";
    else if(ext === "m4a") encryptedExt = ".rpgmvm";
    else if(ext === "png") encryptedExt = ".rpgmvp";
    else encryptedExt = ext;

    return url.slice(0, url.lastIndexOf(ext) - 1) + encryptedExt;
};

Decrypter.extToDecryptExt = function(url) {
    var ext = url.split('.').pop();
    var encryptedExt = ext;

    if(ext === "rpgmvo") encryptedExt = ".ogg";
    else if(ext === "rpgmvm") encryptedExt = ".m4a";
    else if(ext === "rpgmvp") encryptedExt = ".png";
    else if(ext === "png_") encryptedExt = ".png";
    else if(ext === "ogg_") encryptedExt = ".ogg";
    else if(ext === "m4a_") encryptedExt = ".m4a";
    else encryptedExt = ext;

    return url.slice(0, url.lastIndexOf(ext) - 1) + encryptedExt;
};

Decrypter.readEncryptionkey = function(){
    //this._encryptionKey = $dataSystem.encryptionKey.split(/(.{2})/).filter(Boolean);
	this._encryptionKey = this.rawEncriptionKey.split(/(.{2})/).filter(Boolean);
};

RMMVDecrypter.Decrypter = Decrypter;

window.RMMVDecrypter = RMMVDecrypter;

var decryptTo = async function(from, to) {
	console.log("Decrypting", from, to);
	var thisDecrypter = new RMMVDecrypter(from);
	await thisDecrypter.decryptAll(to);
}


/**
 * if engine is rmmv -> /www
 */
var adaptPath = function(path, engine) {
	engine = engine || trans.project.gameEngine;
	if (engine == "rmmv") return nwPath.join(path, "www");

	return path;
}


var applyTranslationPHP = async function(sourceMaterial, targetDir, options) {
	options = options||{};
	options.options		= options.options||{};
	options.mode 		= "dir"; // always dir
	options.onDone 		= options.onDone||function() {};
	options.dataPath 	= options.dataPath || ""; // location of data path (data folder). Default is using cache
	options.transPath	= options.transPath || ""; // location of .trans path to process. Default is using autosave on cache folder
	options.options.filterTag = options.options.filterTag||{};
	options.options.filterTagMode = options.options.filterTagMode||""; // whitelist or blacklist

	var transPath = targetDir+"\\translation.trans";
	var child_process = require('child_process');
	// remove existing data directory
	
	child_process.spawnSync("RMDIR", [targetDir+"\\www\\Data", "/S", "/Q"]);
	
	//ui.loadingClearButton();
	ui.showLoading();
	ui.loadingProgress("Loading", "Copying data...", {consoleOnly:true, mode:'consoleOutput'});
	
	return new Promise(async (resolve, reject) => {
		php.extractEnigma(sourceMaterial, targetDir, {
			onData: function(data) {
			   ui.loadingProgress("Loading", data, {consoleOnly:true, mode:'consoleOutput'});
			},
			onDone: async function() {
			   
			   var autofillFiles = [];
			   var checkbox = $(".fileList .data-selector .fileCheckbox:checked");
			   for (var i=0; i<checkbox.length; i++) {
				   autofillFiles.push(checkbox.eq(i).attr("value"));
			   }
			   options.files = options.files||autofillFiles||[];
			   var hasError = false;
			   await trans.save(transPath);
				//ui.showLoading();
				php.spawn("apply.php", {
					args:{
						gameFolder:trans.gameFolder,
						gameTitle:trans.gameTitle,
						projectId:trans.projectId,
						gameEngine:trans.gameEngine,
						files:options.files,
						exportMode:options.mode,
						options:options.options,
						rpgTransFormat:trans.config.rpgTransFormat,
						transPath:transPath,
						targetPath:targetDir
					},
					onData:function(buffer) {
						ui.loadingProgress("Loading", buffer, {consoleOnly:true, mode:'consoleOutput'});
						
					},
					onError:function(buffer) {
						ui.loadingProgress("Loading", buffer, {consoleOnly:true, mode:'consoleOutput', classStr:'stderr'});
						hasError = true;
					},
					onDone: async function(data) {
						//console.log(data); 
						console.log("done")
						//ui.hideLoading(true);
						ui.loadingEnd("Finished", "All process finished!", {consoleOnly:false, mode:'consoleOutput', error:hasError});
						ui.LoadingAddButton("Open folder", function() {
							nw.Shell.showItemInFolder(transPath);
						},{
							class: "icon-folder-open"
						});
						ui.LoadingAddButton("Play!", function() {
							console.log("Opening game");
							nw.Shell.openItem(targetDir+"\\Game.exe");
						},{
							class: "icon-play"
						});

						ui.showCloseButton();
						if (hasError) {
							var conf = confirm("An error has occured when applying your translation\r\nYour game might can not be played properly.\r\nDo you want to read the online documentation?");
							if (conf) nw.Shell.openExternal(nw.App.manifest.localConfig.defaultDocsUrl+trans.gameEngine);
						}
						
						options.onDone.call(trans, data);
						resolve(trans);
					}
				})

					   
		   }});	
	})
}

var exportToFolderPHP = async function(file, options) {
	// export translation
	if (typeof file=="undefined") return false;
	
	options = options||{};
	options.options = options.options||{};

	options.mode = "dir"; // always dir
	options.onDone = options.onDone||function() {};
	options.dataPath = options.dataPath || ""; // location of data path (data folder). Default is using cache
	options.transPath = options.transPath || ""; // location of .trans path to process. Default is using autosave on cache folder
	options.options.filterTag = options.options.filterTag||[];
	options.options.filterTagMode = options.options.filterTagMode||""; // whitelist or blacklist
	
	console.log("exporting project", arguments);
	
	var autofillFiles = [];
	var checkbox = $(".fileList .data-selector .fileCheckbox:checked");
	for (var i=0; i<checkbox.length; i++) {
		autofillFiles.push(checkbox.eq(i).attr("value"));
	}
	options.files = options.files||autofillFiles||[];

	await trans.autoSave()
	ui.showLoading();

	return new Promise((resolve, reject) => {
		php.spawn("export.php", {
			args:{
				path:file,
				gameFolder:trans.gameFolder,
				gameTitle:trans.gameTitle,
				projectId:trans.projectId,
				gameEngine:trans.gameEngine,
				files:options.files,
				exportMode:options.mode,
				options:options.options,
				rpgTransFormat:trans.config.rpgTransFormat,
				dataPath:options.dataPath,
				transPath:options.transPath
			},
			onData:function(buffer) {
				ui.loadingProgress(t("Loading"), buffer, {consoleOnly:true, mode:'consoleOutput'});
				
			},
			onError:function(buffer) {
				ui.loadingProgress(t("Loading"), buffer, {consoleOnly:true, mode:'consoleOutput', classStr:'stderr'});
				
			},
			onDone: function(data) {
				//console.log(data); 
				console.log("done")
				//ui.hideLoading(true);
				//ui.loadingProgress(t("Finished"), t("All process finished!"), {consoleOnly:false, mode:'consoleOutput'});
				
				//ui.showCloseButton();
				options.onDone.call(trans, data);
				resolve(data);
			}
		})
	})
	
}

var exportToFolder = async function(sourceDir, targetDir, transData, options) {
	console.log("Exporting into a folder exportToFolder():", arguments);
	options = options||{};
	options.writeEncoding = options.writeEncoding || trans.project.writeEncoding;
	transData = transData || trans.getSaveData();
	
	//options.groupIndex = options.groupIndex||"relPath";
	
	var translationData = trans.getTranslationData(transData, options);
	console.log("translation Data : ", translationData);
	var rmmv = new RMMV(sourceDir, {
		'writeMode' : true,
		'translationDatas':translationData.translationData
	});	
	window.rmmv = rmmv;
	
	await rmmv.exportPluginsToFolder(targetDir);

}



var applyTranslation = async function(sourceDir, targetDir, transData, options) {
	options 		= options||{};
	transData 		= transData || trans.getSaveData();
	
	// real path first then temporary
	if (await common.isDirectory(sourceDir)) {
		// directory from inject dialog are root game folder (without www in rmmv)
		sourceDir = adaptPath(targetDir);
	}  else {
		// use stagging data
		sourceDir = transData.project.cache.cachePath;
		if (await common.isDirectory(sourceDir)) {
			// in stagging path, data and js folders are inside data directory
			sourceDir = nwPath.join(sourceDir, "data");
		} else {
			alert("Staging path not found "+sourceDir);
		}
	}

	targetDir = adaptPath(targetDir);
	console.warn("Running post injection ->", arguments);

	console.log("copy from", sourceDir, "to:", targetDir);
	
	await exportToFolder(sourceDir, targetDir, transData, options);

	
}

var createEditorFile = async function(dir, engine) {
	engine = engine || trans.project.gameEngine;
	if (engine == "rmmv") {
		var path = nwPath.join(dir, "www/Game.rpgproject");
		if (await common.isFileAsync(path)) return path;
		await common.writeFile(path, "RPGMV 1.5.0")
	} else {
		var path = nwPath.join(dir, "Game.rmmzproject");
		if (await common.isFileAsync(path)) return path;
		await common.writeFile(path, "RPGMZ 1.0.1")
	}
	return path;
}

var openEditor = async function(dir, engine) {
	engine = engine || trans.project.gameEngine;
	var path = await createEditorFile(dir, engine);
	console.log("opening", path);
	nw.Shell.openExternal(path);

}

var playGame = async function(dir) {
	dir = adaptPath(dir);
	var indexFile = nwPath.join(dir, "index.html");
	nw.Window.open(indexFile, 
	{
		// id will makes the search window will be spawned once
		'id': "mvTestplay"+window.windowIndex
	},
	function(thisWin) {
		//ui.windows['search']
	})
}

var openDecryptorWindow = function(from, to, options) {
	from = from || "";
	to = to || "";
	var $popup = $("#rmmv_decryptorDialog");
	if ($popup.length == 0) {
		var dvField = new DVField();
		$popup = $("<div id='rmmv_decryptorDialog'></div>");
		var $content = ($(`<div>
			<h2 data-tran="">${t('Encrypted game')}</h2>
			<div data-tran="">
				${t('Select the index.html of your encrypted game.')}
			</div>
			<label>
				<input type="dvSelectPath" class="fromPath form-control" accept=".html" value="${from}" />
			</label>
		<div class="tooltip injectDestFolderTooltip error icon-cancel-circled hidden" data-tran="">Field can not be empty!</div>
		</div>
		<div>
			<h2 data-tran="">${t('Target folder')}</h2>
			<div data-tran="">
			${t('Select destination folder. The process will replace the existing files.')}
			</div>
			<label>
				<input type="dvSelectPath" class="toPath form-control" nwdirectory value="${to}" />
			</label>
		<div class="tooltip injectDestFolderTooltip error icon-cancel-circled hidden" data-tran="">Field can not be empty!</div>
		</div>`));
		console.log("rendering ", $popup);
		dvField.renderSelectPath($content.find("[type=dvSelectPath]"));

		$popup.empty();
		$popup.append($content);
	}
	$popup.dialog({
		title: t("Decrypt Resources"),
		autoOpen: false,
		modal:true,
		width:640,
		height:320,
		minWidth:640,
		minHeight:320,
		show: {
			effect: "fade",
			duration: 200
		},
		hide: {
			effect: "fade",
			duration: 200
		},
		buttons:[
			{
				text: t("Close"),
				icon: "ui-icon-close",
				click: function() {
					$(this).dialog( "close" );
				}
			},
			{
				text: t("Process"),
				click: async function() {
					var $this = $(this)
					var from = $this.find(".fromPath").val()
					if (!from) return alert(t("Source path can not empty"));
					var to = $this.find(".toPath").val()
					if (!to) return alert(t("Destination path can not empty"));

					if (await common.isFileAsync(from) == false) return alert(t('Path is not a file:')+from);
					if (await common.isDirectory(to) == false) return alert(t('Invalid directory:')+to);
					
					$this.dialog( "close" );

					ui.showLoading();
					await decryptTo(nwPath.dirname(from),  to);
					ui.showCloseButton();
				}
			}

		]
	});	
	$popup.dialog("open");
}


var extractEnigma = function(from, to, options) {
	from = from || "";
	to = to || "";
	var $popup = $("#rmmv_extractEnigma");
	if ($popup.length == 0) {
		var dvField = new DVField();
		$popup = $("<div id='rmmv_extractEnigma'></div>");
		var $content = ($(`<div>
			<h2 data-tran="">${t('Extract enigma')}</h2>
			<div data-tran="">
				${t('Select enigma file.')}
			</div>
			<label>
				<input type="dvSelectPath" class="fromPath form-control" accept=".exe" value="${from}" />
			</label>
		<div class="tooltip injectDestFolderTooltip error icon-cancel-circled hidden" data-tran="">Field can not be empty!</div>
		</div>
		<div>
			<h2 data-tran="">${t('Target folder')}</h2>
			<div data-tran="">
			${t('Select destination folder. The process will replace the existing files.')}
			</div>
			<label>
				<input type="dvSelectPath" class="toPath form-control" nwdirectory value="${to}" />
			</label>
		<div class="tooltip injectDestFolderTooltip error icon-cancel-circled hidden" data-tran="">Field can not be empty!</div>
		</div>`));
		console.log("rendering ", $popup);
		dvField.renderSelectPath($content.find("[type=dvSelectPath]"));

		$popup.empty();
		$popup.append($content);
	}
	$popup.dialog({
		title: t("Extract Enigma"),
		autoOpen: false,
		modal:true,
		width:640,
		height:320,
		minWidth:640,
		minHeight:320,
		show: {
			effect: "fade",
			duration: 200
		},
		hide: {
			effect: "fade",
			duration: 200
		},
		buttons:[
			{
				text: t("Close"),
				icon: "ui-icon-close",
				click: function() {
					$(this).dialog( "close" );
				}
			},
			{
				text: t("Process"),
				click: async function() {
					var $this = $(this)

					
					var from = $this.find(".fromPath").val();
					var to = $this.find(".toPath").val();

					var isEnigma = await php.isEnigma(from);
					if (!Boolean(isEnigma.result)) return alert(t("Selected file is not an Enigma Virtual Box package."));
					
					$this.dialog( "close" );
					ui.showBusyOverlay();
					await php.extractEnigma(from, to);
					ui.hideBusyOverlay();
				}
			}

		]
	});	
	$popup.dialog("open");
}

var loadPlugins = async function() {
	if (trans.project.pluginIsFetched) {
		var conf = confirm(t("Plugins are already fetched for this project. Want to re-fetch the plugins?"))
		if (!conf) return;
	}

	var thisLoc = trans.project.loc;
	if (trans.gameEngine == "rmmv") {
		thisLoc = nwPath.join(trans.project.loc, "www");
		console.log("Is file js/plugins.js exist?", await common.isFileAsync(nwPath.join(thisLoc, "js/plugins.js")));
		if (await common.isFileAsync(nwPath.join(thisLoc, "js/plugins.js")) == false) thisLoc = trans.project.loc;
	} 

	ui.showBusyOverlay();
	var thisRM = new RMMV(thisLoc);
	// all items stored in a folder named data
	await thisRM.dumpPluginsToDir(nwPath.join(trans.project.cache.cachePath, "data"));
	await thisRM.pluginsToTrans(trans);
	console.log(thisRM);
	trans.drawFileSelector();
	trans.project.pluginIsFetched = true;
	ui.hideBusyOverlay();
}

var confirmLoadPlugins = async function(onOk) {
	onOk = onOk || function() {};
	console.log("open confirmLoadPlugins");
	var $popup = $("#rmmv_fetchJS");
	if ($popup.length == 0) {
		$popup = $("<div id='rmmv_fetchJS'></div>");
		var $content = $(`<h2>Do you also want to load JavaScript files?</h2>
		<div class="blockBox warningBlock withIcon" data-tran="">
				You are about to includes translation for Javascripts!<br />
				Translator++ will fetch all string from plugin related javascript files.<br />
				Most of these strings are not save for translation.<br />
				Make sure you know what you are doing when translating these strings.
		</div>`)
		$popup.empty();
		$popup.append($content);
	}
	$popup.dialog({
		title: t("Translate Javascript File?"),
		autoOpen: false,
		modal:true,
		width:640,
		height:320,
		minWidth:640,
		minHeight:320,
		show: {
			effect: "fade",
			duration: 200
		},
		hide: {
			effect: "fade",
			duration: 200
		},
		buttons:[
			{
				text: t("Cancel"),
				icon: "ui-icon-close",
				click: function() {
					$(this).dialog( "close" );
				}
			},
			{
				text: t("I know the risk, Proceed!"),
				click: async function() {
					var $this = $(this)
					$this.dialog( "close" );
					await onOk.call(this)
				}
			}

		]
	});	
	$popup.dialog("open");
}

var init = function() {
	ui.mainMenu.addChild("tools", {
		id: "rmmv",
		label: "RMMV & RMMZ"
	});

	var $newTransMenu = ui.mainMenu.addChild("rmmv", {
		label: "Decrypt resources"
	});

	$newTransMenu.on("select", function() {
		openDecryptorWindow();
	})

	var $extractEnigma = ui.mainMenu.addChild("rmmv", {
		label: "Extract Enigma Virtual Box"
	});

	$extractEnigma.on("select", function() {
		extractEnigma();
	})
}


var JSONPreview = function(json, htmlClass) {
	if (typeof json !== 'string') json = JSON.stringify(json);
	this.json = json;
	this.htmlClass = htmlClass;
	this.init();
}
JSONPreview.css = `
<style class="jsonPreview">
json-viewver {
    /* Background, font and color */
    --color: #f9f9f9;

}
</style>
`;

JSONPreview.prototype.addContextMenu = function() {
	var that = this;
	this.menu = new nw.Menu();
	// Add some items with label
	this.menu.append(new nw.MenuItem({
		label: t('Find next'),
		type: "normal", 
		click: function(){
			if (!that.elm.data("searcher")) return;
			that.elm.data("searcher").next();
		}
	}));	
	this.menu.append(new nw.MenuItem({ type: 'separator' }));
	this.menu.append(new nw.MenuItem({
		label: t('Open folder'),
		type: "normal", 
		click: function(){
			var filePath = that.elm.data("path");
			if (!filePath) return;
			nw.Shell.showItemInFolder(filePath);
		}
	}));
	this.menu.append(new nw.MenuItem({
		label: t('Open with external application'),
		type: "normal", 
		click: function(){
			var filePath = that.elm.data("path");
			if (!filePath) return;
			nw.Shell.openItem(filePath);			  
		}
	}));

	var that = this;
	this.elm.on("contextmenu", function(ev) {
		ev.preventDefault();
		that.menu.popup(parseInt(ev.originalEvent.x), parseInt(ev.originalEvent.y));
		return false;		
	})
}

JSONPreview.prototype.init = function() {
	var $template = $(`<json-viewer></json-viewer>`);
	$template.attr("title", t(`Raw JSON data. Right click to open menu.`));
	if (this.htmlClass) $template.addClass(this.htmlClass);
	$template.text(this.json);
	this.elm = $template;
	this.addContextMenu();


	if (JSONPreview.isInitialized) return;
	// initializing JSONPreview
	JSONPreview.viewer = require("@alenaksu/json-viewer");
	//$("head").append(JSONPreview.css);
	JSONPreview.isInitialized = true;

}
JSONPreview.prototype.getElement = function() {
	return this.elm;
}

/**
 * Generate direction path from RPG Maker MV styled context string
 * @param  {object} objData
 * @param  {integer} rowNumber
 */
JSONPreview.getDirectionPath = function(objData, rowNumber) {
	objData = objData || {};
	var result = [];
	if (!objData.context) return result;
	if (Array.isArray(objData.context[rowNumber]) == false) return result;
	if (objData.context[rowNumber].length == 0) return result;

	var arrayToPattern = function(array) {
		var str = array.join(".");
		return "**."+str
	}
	
	for (var i in objData.context[rowNumber]) {
		var contextString = objData.context[rowNumber][i];
		var contextSegment = contextString.split("/");
		if (objData.filename.toLowerCase() == "mapinfos.json") {

		} else if (objData.filename.substring(0, 3).toLowerCase() == "map") {
			var segm = contextSegment.slice(1, 6);
			result.push(arrayToPattern(segm));
		}
	}
	return result;
}

JSONPreview.find = function(objData, rowNumber) {
	objData = objData || {};

	if (!objData.context) return;
	if (Array.isArray(objData.context[rowNumber]) == false) return;
	if (objData.context[rowNumber].length == 0) return;	
	if (!objData.data) return;
	if (!objData.data[rowNumber][trans.keyColumn]) return;	
	var previewer = $(".dataPreview")[0];

	var thisMsg = objData.data[rowNumber][trans.keyColumn];
	var firstContext = objData.context[rowNumber][0];
	var firstContextArr = firstContext.split("/");
	if (firstContextArr.includes("message")) {
		thisMsg = thisMsg.replace(/\r/g, "");
		var msgs = thisMsg.split("\n");
		var keyword = msgs[0];
		if (msgs.length>1) keyword = msgs[1];
		var searcher = previewer.search(keyword);
		searcher.next();
	} else {
		var searcher = previewer.search(thisMsg);
		searcher.next();		
	}
	$(".dataPreview").data("searcher", searcher);
}


$(document).ready(function() {
	$(document).on("projectCreated", async function(trans, rawData) {
		// executed when a new project is created and before drawing file list
		if (trans.gameEngine !== "rmmv" && trans.gameEngine !== "rmmz") return;
		var location = trans.loc;
		if (trans.gameEngine == "rmmv") {
			location = nwPath.join(trans.loc, "www");
		} 
		var thisRM = new RMMV(location);
		await thisRM.dumpPluginsToDir(trans.project.cache.cachePath);
		await thisRM.pluginsToTrans(trans);
	})



	if (typeof window.engines.rmmv == 'undefined') engines.add('rmmv');
	if (typeof window.engines.rmmz == 'undefined') engines.add('rmmz');
	engines.addHandler(["rmmv", "rmmz"], 'exportHandler', async function(targetPath, options) {
		if (options.mode !== "dir" && options.mode !== "zip") return false;

		var originPath = nwPath.join(trans.project.cache.cachePath, "data");
		ui.showLoading();
		ui.loadingProgress("Processing", "Export into : "+targetPath, {consoleOnly:false, mode:'consoleOutput'});
		try {
			if (await await common.isDirectory(targetPath)) {
				await exportToFolder(originPath, targetPath)
				ui.loadingProgress("Finished", "All process finished!", {consoleOnly:false, mode:'consoleOutput'});
				ui.showCloseButton();
				return false;
			}
		} catch (e) {
			console.warn(e);
		}
		
		
		// is file
		// export to directory
		var tmpPath = nwPath.join(nw.process.env.TMP, trans.project.projectId);
		fse.removeSync(tmpPath); 
		try {
			fs.mkdirSync(tmpPath, {recursive:true});
		} catch(e) {
			console.warn("Unable to create directory ", tmpPath);
			throw(e);
			return;
		}

		console.log("Exporting to a folder", tmpPath);
		await exportToFolderPHP(tmpPath, options)
		await exportToFolder(originPath, tmpPath)
		console.log("Plugins has been exported to ", tmpPath)
		
		var _7z = require('7zip-min');
		_7z.cmd(['a', '-tzip', targetPath, tmpPath+"\\*"], err => {
			// done
			console.log("process done");
			ui.loadingProgress("Finished", "All process finished!", {consoleOnly:false, mode:'consoleOutput'});
			ui.showCloseButton();				
		});
				
		// prevent default exporting
		return true;
	});


	engines.addHandler(["rmmv", "rmmz"], 'afterInjectHandler', async function(targetDir, sourceMaterial, options) {
		console.log("Path is : ", targetDir);
		console.log("options are : ", options);
		console.log(arguments);

		// convert sourceMaterial to folder if path is file
		var sourceStat = fs.lstatSync(sourceMaterial)
		if (sourceStat.isFile()) sourceMaterial = path.dirname(sourceMaterial);
		
		ui.loadingProgress("Processing", "Additional steps :", {consoleOnly:false, mode:'consoleOutput'});
		ui.loadingProgress("Processing", "Injecting translation for plugins (if any)", {consoleOnly:false, mode:'consoleOutput'});
		await applyTranslation(sourceMaterial, targetDir, trans.getSaveData(), options);
		ui.loadingProgress("Processing", "That's all.", {consoleOnly:false, mode:'consoleOutput'});
		return false;
	});

	engines.addHandler(["rmmv", "rmmz"], "onLoadTrans", 
	() => {
		var appIcon =  "addons/rmmv/rmmv-ico.png"
		if (trans.project.gameEngine == "rmmz") {
			appIcon =  "addons/rmmv/rmmz-ico.png"
		}

		ui.ribbonMenu.add("rm2k", {
			title : trans.gameEngine.toUpperCase(),
			toolbar : {
				buttons : {
					play : {
						icon : "icon-play",
						title : t("Play last build"),
						onClick : async () => {
							if (await common.isDirectory(trans.project.devPath) == false) {
								return alert(t("Dev path is not defined.\nYou should inject your game once to generate dev path."));
							}
							playGame(trans.project.devPath);
						}
					},
					openEditor : {
						img : appIcon,
						title : t("Open editor"),
						onClick : async () => {
							if (await common.isDirectory(trans.project.devPath) == false) {
								return alert(t("Dev path is not defined.\nYou should inject your game once to generate dev path."));
							}
							openEditor(trans.project.devPath, trans.project.gameEngine);
						}
					},
					loadPlugins : {
						icon : "icon-publish",
						title : t("Load Plugins Into Project"),
						onClick : async () => {
							// all items stored in a folder named data
							confirmLoadPlugins(async () => {
								await loadPlugins();
							})

						}
					},
					decryptResources : {
						icon : "icon-lock-open",
						title : t("Decrypt Resources"),
						onClick : async () => {
							var from = trans.project.loc;
							var to = trans.project.devPath

							if (trans.project.gameEngine == "rmmv") {
								from = nwPath.join(from, "www/index.html")
								to 	= nwPath.join(to, "www")
							}
							if (trans.project.gameEngine == "rmmz") from = nwPath.join(from, "index.html")
							openDecryptorWindow(from, to);
						}
					}
					
				}
			}
		})		
	})	

	engines.addHandler(["rmmv", "rmmz"], "onAfterCreateProject", async ()=>{
		$(document).one("hideLoading", async ()=> {
			confirmLoadPlugins(async () => {
				await loadPlugins();
			});
		})
	});	

	
	$(".cellInfoContent.rawData").css("background-color", "#2a2f3a");
	var cropableData = ["commonevents", "actors", "animations", "armors", "classes", "enemies", "items", "skills", "mapinfos", "states", "tilesets", "troops", "weapons"]

	var allowedExtension = [".json", "json", ".js", "js"];
	engines.addHandler(["rmmv", "rmmz"], 'onLoadSnippet', async function(selectedCell) {
		console.log("RMMV/MZ onLoadSnippet handler");
		console.log("selected cell:", selectedCell);

		var obj = trans.getSelectedObject();

		if (obj.extension.toLowerCase() == ".js" && ["js/plugins.js", "/js/plugins.js"].includes(obj.path.toLowerCase()) == false) return this.commonHandleFile(selectedCell, "js");



		if (allowedExtension.includes(obj.extension) == false) return;
		if (!Array.isArray(obj.context[selectedCell.fromRow])) return;
		if (obj.context[selectedCell.fromRow].length == 0) return;

		console.log("determining active path");
		var activePath = nwPath.join(trans.project.loc, obj.path);
		if (trans.project.gameEngine=="rmmv") {
			activePath = nwPath.join(trans.project.loc, "www", obj.path);
			if (await common.isFileAsync(activePath) == false) activePath = nwPath.join(trans.project.loc, obj.path);
		}
		console.log("testing", activePath);
		if (await common.isFileAsync(activePath) == false)  activePath = nwPath.join(trans.project.cache.cachePath, "data", obj.path);
		console.log("testing", activePath);
		if (await common.isFileAsync(activePath) == false) {
			this.clear();
			console.log("no active path");

			$warningMsg = $(`<div class="blockBox warningBlock withIcon">${t(`Unable to find the file related to the data`)}<br />
			${t(`To fix this correct the <b>Raw material location</b> field at the <a href="#" class="openProjectProperties">Project properties</a>`)}</div>`)
			$warningMsg.find(".openProjectProperties").on("click", function() {
				ui.openProjectProperties();
			});
			this.append($warningMsg)
			return;
		}

		if (obj.path == "js/plugins.js" || obj.path == "/js/plugins.js" ) {
			console.log("plugins.js viewer");
			if (this.lastOpenedPath !== activePath || this.isClear()) {
				var addonList = RMMV.getParsedPluginContent(await common.fileGetContents(activePath));
				var jsonPreview = new JSONPreview(addonList, "dataPreview");
				this.jsonPreviewElm = jsonPreview.getElement();
				this.jsonPreviewElm.data("path", activePath);
				this.clear();
				this.append(this.jsonPreviewElm);
				this.lastOpenedPath	 = activePath;
			}

			this.jsonPreviewElm[0].collapseAll()
			JSONPreview.find(obj, selectedCell.fromRow);
		} else {
			console.log("obj.filename.", obj.filename);

			if (this.lastOpenedPath !== activePath || this.isClear()) {
				this.lastOpenedData = await common.fileGetContents(activePath);
				this.lastOpenedPath = activePath;

				var json = this.lastOpenedData
			
			}
			if (cropableData.includes(obj.filename.toLowerCase())) {
				console.log("handling common events");
				// show by each page
				var commonEvents = JSON.parse(this.lastOpenedData);
				var thisContext = trans.getSelectedContext()[0];
				console.log("thisContext", thisContext);
				var contextPart = thisContext.split("/");
				console.log("contextPart", contextPart);
				var json = commonEvents[contextPart[1]];
				console.log(contextPart[1]);
			}		
			if (json) {
				var jsonPreview = new JSONPreview(json, "dataPreview");
				this.jsonPreviewElm = jsonPreview.getElement();
				this.jsonPreviewElm.data("path", activePath);

				this.clear();
				this.append(this.jsonPreviewElm);					
			}	

			this.jsonPreviewElm[0].collapseAll();
			// open related object
			/*
			var opener = JSONPreview.getDirectionPath(obj, selectedCell.fromRow);
			for (var i in opener) {
				console.log("expanding", opener[i]);
				this.jsonPreviewElm[0].expand(opener[i]);
			}
			*/
			// search into related object
			JSONPreview.find(obj, selectedCell.fromRow);
		}
		
	});

	ui.onReady(function() {
		init();
	});
});
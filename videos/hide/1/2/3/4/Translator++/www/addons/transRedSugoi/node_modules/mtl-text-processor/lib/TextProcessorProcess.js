"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextProcessorProcess = void 0;
const TextProcessorRowLine_1 = require("./TextProcessorRowLine");
class TextProcessorProcess {
    constructor(processor, lines) {
        this.internalIndex = 0;
        this.warnings = [];
        this.expectedResponseOrder = [];
        this.expectedResponseLength = 0;
        this.translations = [];
        this.processor = processor;
        this.noRepeat = this.processor.isNoRepeat();
        this.lines = [];
        for (let i = 0; i < lines.length; i++) {
            this.lines.push(new TextProcessorRowLine_1.TextProcessorRowLine(this, lines[i]));
        }
    }
    getProcessor() {
        return this.processor;
    }
    getTranslatableLines() {
        let toTranslate = [];
        for (let i = 0; i < this.lines.length; i++) {
            toTranslate.push(...this.lines[i].getTranslatableStrings());
        }
        if (this.noRepeat) {
            this.expectedResponseOrder = new Array(toTranslate.length);
            this.expectedResponseLength = toTranslate.length;
            let expectedResponseIndex = 0;
            for (let toTranslateIndex = 0; toTranslateIndex < toTranslate.length; toTranslateIndex++) {
                let idx = toTranslate.indexOf(toTranslate[toTranslateIndex]);
                if (idx < toTranslateIndex) {
                    this.expectedResponseOrder[expectedResponseIndex++] = idx;
                    toTranslate.splice(toTranslateIndex, 1);
                    toTranslateIndex--;
                    this.expectedResponseLength--;
                }
                else {
                    this.expectedResponseOrder[expectedResponseIndex++] = toTranslateIndex;
                }
            }
        }
        return toTranslate;
    }
    applyTranslatedLines(lines) {
        let internalLine;
        internalLine = this.lines[this.internalIndex];
        for (let i = 0; i < lines.length; i++) {
            while (internalLine != undefined && internalLine.isDone()) {
                internalLine = this.lines[++this.internalIndex];
            }
            if (internalLine == undefined) {
                console.error('翻译量无效', lines, this);
                throw new Error('收到的翻译量无效。');
            }
            internalLine.addTranslations(lines[i]);
        }
    }
    /**
     * Adds translations to inner strings.
     * It is possible to do it in one pass or multiple, but order and amount is crucial - if a single string is missing or added, it will throw errors. If you return strings in the wrong order, the translation will be inaccurate.
     * Be careful around your translator.
     * @param lines Array of translated lines, must be in the same order as getTranslatableLines
     */
    setTranslatedLines(...lines) {
        if (this.noRepeat) {
            this.translations.push(...lines);
            if (this.translations.length > this.expectedResponseLength) {
                console.error('翻译过多', this);
                throw new Error('收到的翻译太多。');
            }
        }
        else {
            this.applyTranslatedLines(lines);
        }
    }
    getTranslatedLines() {
        if (this.noRepeat) {
            let recoveredTranslations = new Array(this.expectedResponseOrder.length);
            for (let i = 0; i < this.expectedResponseOrder.length; i++) {
                let idx = this.expectedResponseOrder[i];
                if (typeof this.translations[idx] == 'undefined') {
                    console.error('翻译太少', this);
                    throw new Error('收到的翻译太少。');
                }
                recoveredTranslations[i] = this.translations[idx];
            }
            // Delete values
            this.translations = [];
            this.expectedResponseOrder = [];
            this.applyTranslatedLines(recoveredTranslations);
        }
        let lines = [];
        for (let i = 0; i < this.lines.length; i++) {
            lines.push(this.lines[i].getTranslatedString());
        }
        return lines;
    }
    addWarning(options) {
        this.warnings.push({
            originalSentence: options.originalSentence,
            currentSentence: options.currentSentence,
            placeholders: options.placeholders,
            message: options.message
        });
    }
    hasWarnings() {
        return this.warnings.length > 0;
    }
    getWarnings() {
        return [...this.warnings];
    }
}
exports.TextProcessorProcess = TextProcessorProcess;

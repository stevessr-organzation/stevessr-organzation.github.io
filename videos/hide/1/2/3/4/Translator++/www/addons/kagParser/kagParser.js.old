var encoding 	= require('encoding-japanese');
var iconv 		= require('iconv-lite');
var path 		= require('path');
var fs 			= fs || require('fs');
// =================================================================
//  					kag file parser
// =================================================================
var KAGFiles = function(file, options, callback) {	
	this.file = file;
	this.options = this.options || {};
	this.options.literalTags = this.options.literalTags || ["ruby", "l", "r"]
	this.options.literalTags.push("r");
	this.type = "ks";
	this.translatableTexts = [];
	this.buffer;
	this.string;
	this.encoding;
	this.writableData = []; // array represent copy of the writable data
	this.currentContext = [];
	this.writeEncoding = this.options.writeEncoding || 'Windows-31j';
	this.promise;
	
}

KAGFiles.detectEncoding = function(buffer) {
    var d = new Buffer.alloc(5, [0, 0, 0, 0, 0]);
    var fd = fs.openSync(f, 'r');
    fs.readSync(fd, d, 0, 5, 0);
    fs.closeSync(fd);

    // https://en.wikipedia.org/wiki/Byte_order_mark
    var e = false;
    if ( !e && d[0] === 0xEF && d[1] === 0xBB && d[2] === 0xBF)
        e = 'utf8';
    if (!e && d[0] === 0xFE && d[1] === 0xFF)
        e = 'utf16be';
    if (!e && d[0] === 0xFF && d[1] === 0xFE)
        e = 'utf16le';
    if (!e)
        e = 'ascii';

    return e;
	
}

KAGFiles.prototype.getText = function() {
	return this.writableData.join("");
}

KAGFiles.prototype.write = function(file) {
	return new Promise((resolve, reject) => {
		var data = iconv.encode(this.getText(), this.writeEncoding);
		fs.writeFile(file, data, (err)=>{
			if (err) {
				return reject(err);
			}
			
			resolve(file);
			
		})
	})
}

KAGFiles.prototype.contextEnter = function() {
	for (var i=0; i<arguments.length; i++) {
		this.currentContext.push(arguments[0])
	}
}
KAGFiles.prototype.contextEnd = function() {
	this.currentContext.pop()
}

KAGFiles.prototype.filterText = function(text) {
	// filter text for trans
	text = text.replace(/^[\t]+(?=.*\n?)/gm, ''); // remove tab
	text = text.replace(/[\n\r]+/g,'') // remove new line
	
	text = text.replace(/(\[r\])/g, "\n");
	return text;
}

KAGFiles.prototype.unfilterText = function(text) {
	// generate text from trans to raw ks
	text = text.replace(/([\r]+)/g, '');
	text = text.replace(/([\n]+)/g, "[r]\n");
	text = "\n"+text+"\n";
	
	return text;
}

KAGFiles.prototype.translate = function(string) {
	if (string.trim().length == 0) return string;
	return string;
}

KAGFiles.prototype.registerString = function(string, localContext) {
	var copyContext = JSON.parse(JSON.stringify(this.currentContext))
	localContext = localContext||[];
	if (Array.isArray(localContext) == false) localContext = [localContext];
	copyContext = copyContext.concat(localContext);

	if (string.trim().length > 0) {
		this.translatableTexts.push({
			text:this.filterText(string),
			rawText:string,
			context:copyContext
		});
	}

	this.writableData.push(this.translate(string));
	
}

KAGFiles.prototype.register = function(string) {
	this.writableData.push(string);
}




// =================================================================
//  					.tjs file parser
// =================================================================
var TjsFile = function(file, options, callback) {
	this.file = file;
	this.options = this.options || {};
	this.options.literalTags = this.options.literalTags || ["ruby", "l", "r"]
	this.options.literalTags.push("r");
	this.type = "ks";
	this.translatableTexts = [];
	this.buffer;
	this.string;
	this.encoding;
	this.writableData = []; // array represent copy of the writable data
	this.currentContext = [];
	this.writeEncoding = this.options.writeEncoding || 'Windows-31j';
	this.promise;	
}

KAGFiles.prototype.htmlIfy = function(string) {
	string = string || this.string;
	var that = this;
	var ignored = {};
	var iscript = {};
	// substitute escape character [[
	var escaper = "-------"+Date.now()+":"+Math.random()+"-------"
	string = string.replace(/\[\[/g, escaper)
	
	//string = string.replace(/\[ignore[^]]*\](.+?)\[endignore\]/g, '')
	
	// replace @ command with proper [] command
	// string = string.replace(/^([\t]*)[\@](.*(?=\n?))/gm, '[$2]');
	
	
	
	// remove anything between [ignore] [endignore]
	//string = string.replace(/\[ignore\](.+?)\[endignore\]/gs, '')
	string = string.replace(/\[ignore\](.+?)\[endignore\]/gs, function() {
		var escaper = "-------ignored"+ignored.length+Date.now()+":"+Math.random()+"-------"
		ignored[escaper] = arguments[0] // including the outer tag
		return "<ignore>"+escaper+"</ignore>";
	})
	// @ command ignore
	string = string.replace(/^[\t]*\@ignore\s*?(.*?)^[\t]*\@endignore\n?/gsm, function() {
		var escaper = "-------ignored"+ignored.length+Date.now()+":"+Math.random()+"-------"
		ignored[escaper] = arguments[0] // including the outer tag
		return "<ignore>"+escaper+"</ignore>";
	})
	
	
	// remove anything between [iscript] [endscript]
	// script is being handled with different method
	string = string.replace(/\[iscript\](.+?)\[endscript\]/gs, function() {
		var escaper = "-------iscript"+iscript.length+Date.now()+":"+Math.random()+"-------"
		iscript[escaper] = arguments[1] // excluding the outer tag
		return "<iscript>"+escaper+"</iscript>";
	})
	// @ command iscript
	string = string.replace(/^[\t]*\@iscript\s*?(.*?)^[\t]*\@endscript\n?/gsm, function() {
		var escaper = "-------iscript"+iscript.length+Date.now()+":"+Math.random()+"-------"
		iscript[escaper] = arguments[0] // excluding the outer tag
		return "<at-iscript>"+escaper+"</at-iscript>";
	})

	
	// parsing macro
	//string = string.replace(/\[macro\s(.+?)\](.+?)\[endmacro\]/gs, '<macro $1>$2</macro>');
	
	// remove any line starting with ; * @
	// string = string.replace(/^[\;\*\@].*\n?/gm, function() {
	// match tab only with positive look ahead ^[\t]*(?=[\;\*\@].*\n?)
	
	
	//string = string.replace(/^([\t]*)[\;\*\@].*\n?/gm, function() {
	string = string.replace(/^([\t]*)[\;\*].*\n?/gm, function() {
		return "<skip>"+arguments[0]+"</skip>"
	});
	//string = string.replace(/\[/g, "<tag command=");
	//string = string.replace(/\]/g, " />");

	// parsing tags
	//string = string.replace(/\[(.+?)\]/g, '<tag $1 />')
	string = string.replace(/\[(.+?)\]/g, function() {
		var command = arguments[1].split(" ")[0];
		if (that.options.literalTags.includes(command)) return arguments[0];
		return '<tag command="'+command+'" '+arguments[1]+'>'+arguments[0]+'</tag>'
	})
	
	// parsing @ command
	string = string.replace(/^([\t]*)[\@](.*(?=\n?))/gm, function() {
		var command = arguments[2].split(" ")[0];
		console.log(arguments);
		return '<tag command="'+command+'" '+arguments[2]+'>'+arguments[0]+'</tag>'
	});
	
	// bring back escape character [[
	string = string.split(escaper).join("[[")
	for (var boundary in ignored) {
		string = string.split(boundary).join(ignored[boundary])
	}
	for (var boundary in iscript) {
		string = string.split(boundary).join(iscript[boundary])
	}
	
	//console.log(string);
	//return string;
	return $.parseHTML(string);
}

KAGFiles.prototype.unHtmlIfy = function(htmlElement) {
	var htmlString = htmlElement.outerHTML;
	return htmlString;
}

KAGFiles.prototype.parse = function() {
	this.contextEnter(path.basename(this.file));
	this.promise = new Promise((resolve, reject) => {
		fs.readFile(this.file, (err, data) => {
			if (err) return reject();
			
			resolve(data);
		})
		
	}).then((data) => {
		this.buffer = data;
		this.encoding = encoding.detect(data);
		this.string = iconv.decode(this.buffer, this.encoding);

		var htmlElm = this.htmlIfy();
		console.log(htmlElm);
		
		for (var i=0; i<htmlElm.length; i++) {
			var thisElm = htmlElm[i];
			if (thisElm.nodeName !== "#text") {
				// handle non text node
				var commandName = thisElm.getAttribute("command");
				
				if (thisElm.nodeName == 'SKIP') {
					this.register(thisElm.innerHTML);
					continue;
				} else if (thisElm.nodeName == 'ISCRIPT') {
					this.register('[iscript]'+thisElm.innerHTML+'[endscript]');
					continue;
				} else if (thisElm.nodeName == 'IGNORE' || thisElm.nodeName == 'AT-IGNORE') {
					this.register(thisElm.innerHTML);
					continue;
				}
				
				if (KAGFiles.tagFlags[commandName]) {
					if (KAGFiles.tagFlags[commandName].closureType == 'start') this.contextEnter(commandName)
					if (KAGFiles.tagFlags[commandName].closureType == 'end') this.contextEnd(commandName)
					
				}

				this.register(thisElm.innerHTML);
				continue;
			};
			
			// handle text node
			this.registerString(thisElm.textContent, ["text", i]);
		}
		
		this.contextEnd();
	})
	
	return this.promise;
	
}


// =================================================================
//  					.ks file parser
// =================================================================
var KsFile = function(file, options, callback) {	
	this.file = file;
	this.options = this.options || {};
	this.options.literalTags = this.options.literalTags || ["ruby", "l", "r"]
	this.options.literalTags.push("r");
	this.type = "ks";
	this.translatableTexts = [];
	this.buffer;
	this.string;
	this.encoding;
	this.writableData = []; // array represent copy of the writable data
	this.currentContext = [];
	this.writeEncoding = this.options.writeEncoding || 'Windows-31j';
	this.promise;
	
}

KsFile.tagFlags = {
	'macro' : {
		closureType:'start'
	}
	,'endmacro' : {
		closureType:'end'
	}
	
}

KsFile.parser = function(data) {
	
}

KsFile.detectEncoding = function(buffer) {
    var d = new Buffer.alloc(5, [0, 0, 0, 0, 0]);
    var fd = fs.openSync(f, 'r');
    fs.readSync(fd, d, 0, 5, 0);
    fs.closeSync(fd);

    // https://en.wikipedia.org/wiki/Byte_order_mark
    var e = false;
    if ( !e && d[0] === 0xEF && d[1] === 0xBB && d[2] === 0xBF)
        e = 'utf8';
    if (!e && d[0] === 0xFE && d[1] === 0xFF)
        e = 'utf16be';
    if (!e && d[0] === 0xFF && d[1] === 0xFE)
        e = 'utf16le';
    if (!e)
        e = 'ascii';

    return e;
	
}

KsFile.prototype.getText = function() {
	return this.writableData.join("");
}

KsFile.prototype.write = function(file) {
	return new Promise((resolve, reject) => {
		var data = iconv.encode(this.getText(), this.writeEncoding);
		fs.writeFile(file, data, (err)=>{
			if (err) {
				return reject(err);
			}
			
			resolve(file);
			
		})
	})
}

KsFile.prototype.contextEnter = function() {
	for (var i=0; i<arguments.length; i++) {
		this.currentContext.push(arguments[0])
	}
}
KsFile.prototype.contextEnd = function() {
	this.currentContext.pop()
}

KsFile.prototype.filterText = function(text) {
	// filter text for trans
	text = text.replace(/^[\t]+(?=.*\n?)/gm, ''); // remove tab
	text = text.replace(/[\n\r]+/g,'') // remove new line
	
	text = text.replace(/(\[r\])/g, "\n");
	return text;
}

KsFile.prototype.unfilterText = function(text) {
	// generate text from trans to raw ks
	text = text.replace(/([\r]+)/g, '');
	text = text.replace(/([\n]+)/g, "[r]\n");
	text = "\n"+text+"\n";
	
	return text;
}

KsFile.prototype.translate = function(string) {
	if (string.trim().length == 0) return string;
	return string;
}

KsFile.prototype.registerString = function(string, localContext) {
	var copyContext = JSON.parse(JSON.stringify(this.currentContext))
	localContext = localContext||[];
	if (Array.isArray(localContext) == false) localContext = [localContext];
	copyContext = copyContext.concat(localContext);

	if (string.trim().length > 0) {
		this.translatableTexts.push({
			text:this.filterText(string),
			rawText:string,
			context:copyContext
		});
	}

	this.writableData.push(this.translate(string));
	
}

KsFile.prototype.register = function(string) {
	this.writableData.push(string);
}

KsFile.prototype.htmlIfy = function(string) {
	string = string || this.string;
	var that = this;
	var ignored = {};
	var iscript = {};
	// substitute escape character [[
	var escaper = "-------"+Date.now()+":"+Math.random()+"-------"
	string = string.replace(/\[\[/g, escaper)
	
	//string = string.replace(/\[ignore[^]]*\](.+?)\[endignore\]/g, '')
	
	// replace @ command with proper [] command
	// string = string.replace(/^([\t]*)[\@](.*(?=\n?))/gm, '[$2]');
	
	
	
	// remove anything between [ignore] [endignore]
	//string = string.replace(/\[ignore\](.+?)\[endignore\]/gs, '')
	string = string.replace(/\[ignore\](.+?)\[endignore\]/gs, function() {
		var escaper = "-------ignored"+ignored.length+Date.now()+":"+Math.random()+"-------"
		ignored[escaper] = arguments[0] // including the outer tag
		return "<ignore>"+escaper+"</ignore>";
	})
	// @ command ignore
	string = string.replace(/^[\t]*\@ignore\s*?(.*?)^[\t]*\@endignore\n?/gsm, function() {
		var escaper = "-------ignored"+ignored.length+Date.now()+":"+Math.random()+"-------"
		ignored[escaper] = arguments[0] // including the outer tag
		return "<ignore>"+escaper+"</ignore>";
	})
	
	
	// remove anything between [iscript] [endscript]
	// script is being handled with different method
	string = string.replace(/\[iscript\](.+?)\[endscript\]/gs, function() {
		var escaper = "-------iscript"+iscript.length+Date.now()+":"+Math.random()+"-------"
		iscript[escaper] = arguments[1] // excluding the outer tag
		return "<iscript>"+escaper+"</iscript>";
	})
	// @ command iscript
	string = string.replace(/^[\t]*\@iscript\s*?(.*?)^[\t]*\@endscript\n?/gsm, function() {
		var escaper = "-------iscript"+iscript.length+Date.now()+":"+Math.random()+"-------"
		iscript[escaper] = arguments[0] // excluding the outer tag
		return "<at-iscript>"+escaper+"</at-iscript>";
	})

	
	// parsing macro
	//string = string.replace(/\[macro\s(.+?)\](.+?)\[endmacro\]/gs, '<macro $1>$2</macro>');
	
	// remove any line starting with ; * @
	// string = string.replace(/^[\;\*\@].*\n?/gm, function() {
	// match tab only with positive look ahead ^[\t]*(?=[\;\*\@].*\n?)
	
	
	//string = string.replace(/^([\t]*)[\;\*\@].*\n?/gm, function() {
	string = string.replace(/^([\t]*)[\;\*].*\n?/gm, function() {
		return "<skip>"+arguments[0]+"</skip>"
	});
	//string = string.replace(/\[/g, "<tag command=");
	//string = string.replace(/\]/g, " />");

	// parsing tags
	//string = string.replace(/\[(.+?)\]/g, '<tag $1 />')
	string = string.replace(/\[(.+?)\]/g, function() {
		var command = arguments[1].split(" ")[0];
		if (that.options.literalTags.includes(command)) return arguments[0];
		return '<tag command="'+command+'" '+arguments[1]+'>'+arguments[0]+'</tag>'
	})
	
	// parsing @ command
	string = string.replace(/^([\t]*)[\@](.*(?=\n?))/gm, function() {
		var command = arguments[2].split(" ")[0];
		console.log(arguments);
		return '<tag command="'+command+'" '+arguments[2]+'>'+arguments[0]+'</tag>'
	});
	
	// bring back escape character [[
	string = string.split(escaper).join("[[")
	for (var boundary in ignored) {
		string = string.split(boundary).join(ignored[boundary])
	}
	for (var boundary in iscript) {
		string = string.split(boundary).join(iscript[boundary])
	}
	
	//console.log(string);
	//return string;
	return $.parseHTML(string);
}

KsFile.prototype.unHtmlIfy = function(htmlElement) {
	var htmlString = htmlElement.outerHTML;
	return htmlString;
}

KsFile.prototype.parse = function() {
	this.contextEnter(path.basename(this.file));
	this.promise = new Promise((resolve, reject) => {
		fs.readFile(this.file, (err, data) => {
			if (err) return reject();
			
			resolve(data);
		})
		
	}).then((data) => {
		this.buffer = data;
		this.encoding = encoding.detect(data);
		this.string = iconv.decode(this.buffer, this.encoding);

		var htmlElm = this.htmlIfy();
		console.log(htmlElm);
		
		for (var i=0; i<htmlElm.length; i++) {
			var thisElm = htmlElm[i];
			if (thisElm.nodeName !== "#text") {
				// handle non text node
				var commandName = thisElm.getAttribute("command");
				
				if (thisElm.nodeName == 'SKIP') {
					this.register(thisElm.innerHTML);
					continue;
				} else if (thisElm.nodeName == 'ISCRIPT') {
					this.register('[iscript]'+thisElm.innerHTML+'[endscript]');
					continue;
				} else if (thisElm.nodeName == 'IGNORE' || thisElm.nodeName == 'AT-IGNORE') {
					this.register(thisElm.innerHTML);
					continue;
				}
				
				if (KsFile.tagFlags[commandName]) {
					if (KsFile.tagFlags[commandName].closureType == 'start') this.contextEnter(commandName)
					if (KsFile.tagFlags[commandName].closureType == 'end') this.contextEnd(commandName)
					
				}

				this.register(thisElm.innerHTML);
				continue;
			};
			
			// handle text node
			this.registerString(thisElm.textContent, ["text", i]);
		}
		
		this.contextEnd();
	})
	
	return this.promise;
	
}



var KAGJs = function(dir, options, callback) {
	this.dir = path.normalize(dir);
	this.options = options || {};
	this.contextSeparator = this.options.contextSeparator || "/"
	this.showBlank = this.options.showBlank || false;
	this.callback = callback || function() {}
	this.promise;
	this.isInitialized = false;
	this.translatable = {};
}
KAGJs.prototype.getRelativePath = function(stringPath) {
	stringPath = path.normalize(stringPath);
	
	return stringPath.substring(this.dir.length, stringPath.length);
}

KAGJs.prototype.readDir = function(dir) {
  return new Promise((resolve, reject) => {
    fs.readdir(dir, (error, files) => {
      if (error) {
        return reject(error);
      }
      Promise.all(files.map((file) => {
        return new Promise((resolve, reject) => {
          const filepath = path.join(dir, file);
          fs.stat(filepath, (error, stats) => {
            if (error) {
              return reject(error);
            }
            if (stats.isDirectory()) {
              this.readDir(filepath).then(resolve);
            } else if (stats.isFile()) {
              resolve(filepath);
            }
          });
        });
      }))
      .then((foldersContents) => {
        resolve(foldersContents.reduce((all, folderContents) => all.concat(folderContents), []));
      });
    });
  });
	
}



KAGJs.prototype.generateData = function(fileObject) {
	var result = {
		data:[],
		context:[],
		tags:[],
		indexIds:{}
	}
	if (!fileObject.translatableTexts) return result;
	
	for (var i=0; i<fileObject.translatableTexts.length; i++) {
		var thisObj = fileObject.translatableTexts[i];

		result.indexIds[thisObj.text] = result.indexIds[thisObj.text] || result.data.length;
		
		var row = result.indexIds[thisObj.text];
		result.data[row] 	= result.data[row] || [thisObj.text, ""];
		result.context[row] = result.context[row]||[];
		result.context[row].push(thisObj.context.join(this.contextSeparator))
	}
	
	return result;
	
}

KAGJs.prototype.toTrans = function() {
	if (this.isInitialized == false) return console.error('Not initialized, Run init() first!');
	var transData = {
		project:{
			files:{}
		}
	}
	
	for (var relpath in this.translatable) {
		var thisTranslatable = this.translatable[relpath]
		if (thisTranslatable.type == 'ks') {
			var thisData = {};
			
			
			var thisGenData = this.generateData(thisTranslatable);
			if (!this.showBlank) if (thisGenData.data.length < 1) continue;
			thisData = {};
			thisData.data 		= thisGenData.data
			thisData.context 	= thisGenData.context
			thisData.tags 		= thisGenData.tags
			thisData.filename 	= path.basename(relpath);
			thisData.basename 	= path.basename(relpath);
			thisData.indexIds 	= thisGenData.indexIds
			//thisData.groupLevel 	= thisGenData.groupLevel;	
			thisData.extension 	= path.extname(relpath);
			thisData.lineBreak 	= "\n";
			thisData.path 		= relpath // path is relative path from cache dir
			thisData.relPath 		= relpath // relpath is real filename address on context	
			thisData.type 		= null; // no special type
			thisData.originalFormat = "KAG's .ks File";			
			thisData.dirname 		= path.dirname(relpath);	
			
			transData.project.files[relpath] = thisData;
		}
		
		
	}
	return transData;
	
}

KAGJs.prototype.init = function() {
	var promises = [];
	
	return new Promise((resolve, reject) =>{
		this.readDir(this.dir)
		.then((files) => {
			console.log(files);
			for (var i=0; i<files.length; i++) {
				var thisFile = files[i];
				var relativePath = this.getRelativePath(thisFile);
				if (path.extname(thisFile).toLowerCase() == ".ks") {
					var thisKS = new KsFile(thisFile, this.options);
					this.translatable[relativePath] = thisKS;
					promises.push(thisKS.parse())
				}
			}
			
			this.isInitialized = true;
			
			return;
		}).then(() => {
			Promise.all(promises)
			.then(()=> {
				console.warn("promise all is resolved");
				console.log("promises : ", promises);
				resolve()
			})			
		})
	})

}

//var ksFile = new KsFile('F:/test/KAG3/amakan/data/scenario/first.ks');
//var ksFile = new KsFile('F:/test/KAG3/test.ks');
//console.log(ksFile);


/*
convert .ks to xmlize data by replacing [ to < and ] to >
[end to </ 



macro endmacro if else elsif endif ignore endignore iscript endscript 

ignore anything inside [ignore] & [endignore]
parse anything inside [isscript] & [endscript]


cancelautomode	(Canceling "Automatically read through")
cancelskip	(Cancel skip)
ch	(Display characters)
cm	(Clear all message layers)
ct	(Reset message layer)
current	(Specify the message layer to be operated)
deffont	(Default character attribute setting)
defstyle	(Set default style)
delay	(Set character display speed)
endindent	(Remove indent)
endnowait	(Character display no wait (end of))
er	(Erase message layer characters)
font	(Character attribute setting)
glyph	(Specify click wait symbol)
graph	(Inline image display)
hch	(Display vertical-in-vertical display)
indent	(Set indent)
l	(Wait for line end click) <-- literal
locate	(Specify character display position)
locklink	(Link lock)
nowait	(Character display no weight)
p	(Waiting for page break click) <-- literal
position	(Message layer attribute)
r	( Begin on a new line ) <-- literal
resetfont	(Reset character attribute to default)
resetstyle	(Reset style to default)
ruby	(Specify ruby)
style	(Style settings)
unlocklink	(Unlock link)


WHEN EXPORTING : 
generate from line break : [r]

SCRIPTS :
capture all string inside quote
/(?<=(["']\b))(?:(?=(\\?))\2.)*?(?=\1)/g


*/

function createProject(sourceDir, options) {
	options = options || {}
	var projectId 		= common.makeid(10);
	var targetDir 		= nw.process.env.TMP+'\\'+projectId;
	
	var kagjs = new KAGJs(sourceDir);	
	var ksFiles = [];
	return bCopy(sourceDir, targetDir, {
		filter: function(src, dest) {
			console.log("copying ",src, dest);
			ui.loadingProgress("Preparing", "Copying : "+src, {consoleOnly:true, mode:'consoleOutput'});
			if (path.extname(dest).toLowerCase() == '.ks') {
				ksFiles.push(dest)
				return true;
			}
			return false;
		},
		overwrite:true
	})
	.then(()=>{
		return kagjs.init();
	})
	.then(()=>{
		var transData = kagjs.toTrans();
		transData.project.projectId = projectId;
		transData.project.cache = transData.project.cache||{};
		transData.project.cache.cachePath = common.getStagePath()+"/"+projectId;
		
		ui.loadingProgress("Processing", "Parsing done!", {consoleOnly:true, mode:'consoleOutput'});
		ui.loadingProgress("Processing", "Creating new Project.", {consoleOnly:true, mode:'consoleOutput'});
		console.warn("trans data : ", transData);
		
		trans.openFromTransObj(transData, {isNew:true});
		ui.loadingProgress("Done", "All done", {consoleOnly:true, mode:'consoleOutput'});
		ui.loadingEnd("Done", "Done");
		trans.autoSave();
		ui.showCloseButton();	
	})
}


function init() {
	console.warn("INITIALIZING KAG Parser");
	var $slide = $(`
		<h1><i class="icon-plus-circled"></i>Kirikiri Adventure Game</h1>
		<div class="blockBox infoBlock withIcon">
			<h2>I Thank you All!</h2>
			400 monthly patrons has been reached!<br />
			This feature is available because of your continous support!<br />
		</div>
		
		<div class="fieldgroup">
			<div class="actionButtons">
			</div>
		</div>			
			`);
	var $button = $('<button class="btnSelectExe selectRPGExe"><i class="icon-doc-inv"></i>Select executable file from your the game</button>')
	$button.on('click', function() {
		ui.openFileDialog({
			accept:".exe",
			onSelect : function(selectedFile) {
				ui.showLoading();
				var selectedDir = path.dirname(selectedFile);
				ui.loadingProgress("Processing", "Processing : "+selectedDir, {consoleOnly:true, mode:'consoleOutput'});
				ui.loadingProgress("Processing", "Please wait! The Window will appear like it's hang up for a large game. It is normal.", {consoleOnly:true, mode:'consoleOutput'});
				ui.newProjectDialog.close()

				new Promise((resolve, reject) => {
					return createProject(selectedDir)

				}).then(function() {
					ui.loadingProgress("Processing", "Parsing .ks files...", {consoleOnly:true, mode:'consoleOutput'});
					
				})
			}
		})		
	})
	$slide.find(".actionButtons").append($button);
	
	ui.newProjectDialog.addMenu({
		icon : "addons/kagParser/icon.png",
		descriptionBar : `<h2>Kirikiri Adventure Game</h2>
						<p>Start translation from KAG Games</p>`,
		actionBar: "",
		goToSlide: 60,
		at:3,
		slides : {
			60: $slide
		}
	})	
	
}

$(document).ready(function() {
	ui.onReady(function() {
		init();
	});
});
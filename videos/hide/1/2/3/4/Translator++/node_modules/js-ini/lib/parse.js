"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decode = exports.parse = void 0;
const errors_1 = require("./errors");
const auto_type_1 = require("./helpers/auto-type");
const proto_1 = require("./proto");
const sectionNameRegex = /\[(.*)]$/;
function parse(data, params) {
    const { delimiter = '=', comment = ';', nothrow = false, autoTyping = true, dataSections = [], protoSymbol = false, } = Object.assign({}, params);
    let typeParser;
    if (typeof autoTyping === 'function') {
        typeParser = autoTyping;
    }
    else {
        typeParser = autoTyping ? auto_type_1.autoType : (val) => val;
    }
    const lines = data.split(/\r?\n/g);
    let lineNumber = 0;
    let currentSection = '';
    let isDataSection = false;
    const result = {};
    for (const rawLine of lines) {
        lineNumber += 1;
        const line = rawLine.trim();
        if ((line.length === 0) || (line.startsWith(comment))) {
            continue;
        }
        else if (line[0] === '[') {
            const match = line.match(sectionNameRegex);
            if (match !== null) {
                currentSection = match[1].trim();
                if (currentSection === '__proto__') {
                    if (protoSymbol) {
                        currentSection = proto_1.$Proto;
                    }
                    else {
                        throw new errors_1.ProtoError(lineNumber);
                    }
                }
                isDataSection = dataSections.includes(currentSection);
                if (!(currentSection in result)) {
                    result[currentSection] = (isDataSection) ? [] : Object.create(null);
                }
                continue;
            }
        }
        else if (isDataSection) {
            result[currentSection].push(rawLine);
            continue;
        }
        else if (line.includes(delimiter)) {
            const posOfDelimiter = line.indexOf(delimiter);
            const name = line.slice(0, posOfDelimiter).trim();
            const rawVal = line.slice(posOfDelimiter + 1).trim();
            const val = typeParser(rawVal, currentSection, name);
            if (currentSection !== '') {
                result[currentSection][name] = val;
            }
            else {
                result[name] = val;
            }
            continue;
        }
        const error = new errors_1.ParsingError(line, lineNumber);
        if (!nothrow) {
            throw error;
        }
        else if (errors_1.$Errors in result) {
            result[errors_1.$Errors].push(error);
        }
        else {
            result[errors_1.$Errors] = [error];
        }
    }
    return result;
}
exports.parse = parse;
exports.decode = parse;